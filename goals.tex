\begin{tacticblock}
\textbf{Tactic:} \texttt{set g : ℝ → ℝ := fun x => Real.log (f x / f 0)}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
⊢ ∃ c, ∀ (x : ℝ), f x = f 0 * rexp (c * x)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{have hg_add : ∀ a b, g a + g b = g (a + b) := by
  -- Substitute the definition of $g$ into the equation and use the functional equation $hf$.
  
  intros a b
  simp [g];
  rw [← Real.log_mul (ne_of_gt (div_pos (hf_pos _) (hf_pos _))) (ne_of_gt (div_pos (hf_pos _) (hf_pos _))),
    div_mul_div_comm];
  rw [hf a b]; rw [mul_div_mul_left _ _ (ne_of_gt (hf_pos 0))];
  -- Since $g$ is continuous and satisfies $g(a) + g(b) = g(a+b)$, it must be linear.
  }\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
⊢ ∃ c, ∀ (x : ℝ), f x = f 0 * rexp (c * x)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{intros a b}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
⊢ ∀ (a b : ℝ), g a + g b = g (a + b)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{simp [g]}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
a b : ℝ
⊢ g a + g b = g (a + b)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{rw [← Real.log_mul (ne_of_gt (div_pos (hf_pos _) (hf_pos _))) (ne_of_gt (div_pos (hf_pos _) (hf_pos _))),
  div_mul_div_comm]}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
a b : ℝ
⊢ log (f a / f 0) + log (f b / f 0) = log (f (a + b) / f 0)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{rw [hf a b]}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
a b : ℝ
⊢ log (f a * f b / (f 0 * f 0)) = log (f (a + b) / f 0)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{rw [mul_div_mul_left _ _ (ne_of_gt (hf_pos 0))]}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
a b : ℝ
⊢ log (f 0 * f (a + b) / (f 0 * f 0)) = log (f (a + b) / f 0)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{have hg_linear : ∃ c : ℝ, ∀ x, g x = c * x :=
  by
  have hg_linear : ∀ q : ℚ, g q = q * g 1 := by
    -- By induction on $n$, we can show that $g(nx) = ng(x)$ for any integer $n$.
    
    have hg_int : ∀ n : ℤ, ∀ x : ℝ, g (n * x) = n * g x := by
      -- We'll use induction on $n$ to show that $g(nx) = ng(x)$ for any integer $n$.
      
      intros n x
      induction' n using Int.induction_on with n ih; · simp +zetaDelta at *;
      · have := hg_add (n * x) x; push_cast at *; ring_nf at *; linarith;
      · grind;
        -- By definition of rational numbers, for any rational number $q$, we can write $q = \frac{m}{n}$ where $m$ and $n$ are integers.
        
    intro q
    obtain ⟨m, n, hn_ne_zero, hq⟩ : ∃ m n : ℤ, n ≠ 0 ∧ q = m / n := by
      exact ⟨q.num, q.den, Nat.cast_ne_zero.mpr q.pos.ne', q.num_div_den.symm⟩;
    have := hg_int n (1 / n); simp_all +decide [div_eq_mul_inv, mul_assoc];
    -- Since $g$ is continuous and linear over the rationals, it must be linear over the reals.
    
  have hg_cont : Continuous g := by
    exact Continuous.log (hf_cont.div_const _) fun x => ne_of_gt (div_pos (hf_pos x) (hf_pos 0));
  use g 1; intros x
  by_contra hg_nonlinear;
  -- Since $g$ is continuous and $g(x) \neq g(1) * x$, there exists a neighborhood around $x$ where $g$ does not take the form $g(1) * x$.
  obtain ⟨ε, hε⟩ : ∃ ε > 0, ∀ y, abs (y - x) < ε → g y ≠ g 1 * y := by
    exact
      Metric.mem_nhds_iff.mp
        (IsOpen.mem_nhds (isOpen_compl_iff.mpr <| isClosed_eq hg_cont <| continuous_const.mul continuous_id')
          hg_nonlinear);
  rcases exists_rat_btwn (show x - ε < x by linarith) with ⟨q, hq₁, hq₂⟩;
  exact hε.2 q (abs_lt.2 ⟨by linarith, by linarith⟩) (by linarith [hg_linear q]);}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
⊢ ∃ c, ∀ (x : ℝ), f x = f 0 * rexp (c * x)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{have hg_linear : ∀ q : ℚ, g q = q * g 1 := by
  -- By induction on $n$, we can show that $g(nx) = ng(x)$ for any integer $n$.
  
  have hg_int : ∀ n : ℤ, ∀ x : ℝ, g (n * x) = n * g x := by
    -- We'll use induction on $n$ to show that $g(nx) = ng(x)$ for any integer $n$.
    
    intros n x
    induction' n using Int.induction_on with n ih; · simp +zetaDelta at *;
    · have := hg_add (n * x) x; push_cast at *; ring_nf at *; linarith;
    · grind;
      -- By definition of rational numbers, for any rational number $q$, we can write $q = \frac{m}{n}$ where $m$ and $n$ are integers.
      
  intro q
  obtain ⟨m, n, hn_ne_zero, hq⟩ : ∃ m n : ℤ, n ≠ 0 ∧ q = m / n := by
    exact ⟨q.num, q.den, Nat.cast_ne_zero.mpr q.pos.ne', q.num_div_den.symm⟩;
  have := hg_int n (1 / n); simp_all +decide [div_eq_mul_inv, mul_assoc];
  -- Since $g$ is continuous and linear over the rationals, it must be linear over the reals.
  }\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
⊢ ∃ c, ∀ (x : ℝ), g x = c * x\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{have hg_int : ∀ n : ℤ, ∀ x : ℝ, g (n * x) = n * g x := by
  -- We'll use induction on $n$ to show that $g(nx) = ng(x)$ for any integer $n$.
  
  intros n x
  induction' n using Int.induction_on with n ih; · simp +zetaDelta at *;
  · have := hg_add (n * x) x; push_cast at *; ring_nf at *; linarith;
  · grind;
    -- By definition of rational numbers, for any rational number $q$, we can write $q = \frac{m}{n}$ where $m$ and $n$ are integers.
    }\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
⊢ ∀ (q : ℚ), g ↑q = ↑q * g 1\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{intros n x}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
⊢ ∀ (n : ℤ) (x : ℝ), g (↑n * x) = ↑n * g x\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{induction' n using Int.induction_on with n ih}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
n : ℤ
x : ℝ
⊢ g (↑n * x) = ↑n * g x\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{simp +zetaDelta at *}\\
\textbf{Goal:} \begin{verbatim}case zero
f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
x : ℝ
⊢ g (↑0 * x) = ↑0 * g x\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{have := hg_add (n * x) x}\\
\textbf{Goal:} \begin{verbatim}case succ
f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
x : ℝ
n : ℕ
ih : g (↑↑n * x) = ↑↑n * g x
⊢ g (↑(↑n + 1) * x) = ↑(↑n + 1) * g x\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{push_cast at *}\\
\textbf{Goal:} \begin{verbatim}case succ
f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
x : ℝ
n : ℕ
ih : g (↑↑n * x) = ↑↑n * g x
this : g (↑n * x) + g x = g (↑n * x + x)
⊢ g (↑(↑n + 1) * x) = ↑(↑n + 1) * g x\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{ring_nf at *}\\
\textbf{Goal:} \begin{verbatim}case succ
f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
x : ℝ
n : ℕ
this : g (↑n * x) + g x = g (↑n * x + x)
ih : g (↑n * x) = ↑n * g x
⊢ g ((↑n + 1) * x) = (↑n + 1) * g x\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{linarith}\\
\textbf{Goal:} \begin{verbatim}case succ
f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
x : ℝ
n : ℕ
ih : g (↑n * x) = ↑n * g x
this : g x + g (↑n * x) = g (↑n * x + x)
⊢ g (↑n * x + x) = ↑n * g x + g x\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{grind}\\
\textbf{Goal:} \begin{verbatim}case pred
f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
x : ℝ
i✝ : ℕ
a✝ : g (↑(-↑i✝) * x) = ↑(-↑i✝) * g x
⊢ g (↑(-↑i✝ - 1) * x) = ↑(-↑i✝ - 1) * g x\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{intro q}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_int : ∀ (n : ℤ) (x : ℝ), g (↑n * x) = ↑n * g x
⊢ ∀ (q : ℚ), g ↑q = ↑q * g 1\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{obtain ⟨m, n, hn_ne_zero, hq⟩ : ∃ m n : ℤ, n ≠ 0 ∧ q = m / n := by
  exact ⟨q.num, q.den, Nat.cast_ne_zero.mpr q.pos.ne', q.num_div_den.symm⟩;}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_int : ∀ (n : ℤ) (x : ℝ), g (↑n * x) = ↑n * g x
q : ℚ
⊢ g ↑q = ↑q * g 1\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{exact ⟨q.num, q.den, Nat.cast_ne_zero.mpr q.pos.ne', q.num_div_den.symm⟩}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_int : ∀ (n : ℤ) (x : ℝ), g (↑n * x) = ↑n * g x
q : ℚ
⊢ ∃ m n, n ≠ 0 ∧ q = ↑m / ↑n\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{have := hg_int n (1 / n)}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_int : ∀ (n : ℤ) (x : ℝ), g (↑n * x) = ↑n * g x
q : ℚ
m n : ℤ
hn_ne_zero : n ≠ 0
hq : q = ↑m / ↑n
⊢ g ↑q = ↑q * g 1\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{simp_all +decide [div_eq_mul_inv, mul_assoc]}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_int : ∀ (n : ℤ) (x : ℝ), g (↑n * x) = ↑n * g x
q : ℚ
m n : ℤ
hn_ne_zero : n ≠ 0
hq : q = ↑m / ↑n
this : g (↑n * (1 / ↑n)) = ↑n * g (1 / ↑n)
⊢ g ↑q = ↑q * g 1\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{have hg_cont : Continuous g := by
  exact Continuous.log (hf_cont.div_const _) fun x => ne_of_gt (div_pos (hf_pos x) (hf_pos 0));}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1
⊢ ∃ c, ∀ (x : ℝ), g x = c * x\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{exact Continuous.log (hf_cont.div_const _) fun x => ne_of_gt (div_pos (hf_pos x) (hf_pos 0))}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1
⊢ Continuous g\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{use g 1}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1
hg_cont : Continuous g
⊢ ∃ c, ∀ (x : ℝ), g x = c * x\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{intros x}\\
\textbf{Goal:} \begin{verbatim}case h
f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := ⋯
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1
hg_cont : Continuous g
⊢ ∀ (x : ℝ), g x = g 1 * x\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{by_contra hg_nonlinear}\\
\textbf{Goal:} \begin{verbatim}case h
f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1
hg_cont : Continuous g
x : ℝ
⊢ g x = g 1 * x\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{obtain ⟨ε, hε⟩ : ∃ ε > 0, ∀ y, abs (y - x) < ε → g y ≠ g 1 * y := by
  exact
    Metric.mem_nhds_iff.mp
      (IsOpen.mem_nhds (isOpen_compl_iff.mpr <| isClosed_eq hg_cont <| continuous_const.mul continuous_id')
        hg_nonlinear);}\\
\textbf{Goal:} \begin{verbatim}case h
f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1
hg_cont : Continuous g
x : ℝ
hg_nonlinear : ¬g x = g 1 * x
⊢ False\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{exact
  Metric.mem_nhds_iff.mp
    (IsOpen.mem_nhds (isOpen_compl_iff.mpr <| isClosed_eq hg_cont <| continuous_const.mul continuous_id') hg_nonlinear)}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1
hg_cont : Continuous g
x : ℝ
hg_nonlinear : ¬g x = g 1 * x
⊢ ∃ ε > 0, ∀ (y : ℝ), |y - x| < ε → g y ≠ g 1 * y\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{rcases exists_rat_btwn (show x - ε < x by linarith) with ⟨q, hq₁, hq₂⟩}\\
\textbf{Goal:} \begin{verbatim}case h
f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1
hg_cont : Continuous g
x : ℝ
hg_nonlinear : ¬g x = g 1 * x
ε : ℝ
hε : ε > 0 ∧ ∀ (y : ℝ), |y - x| < ε → g y ≠ g 1 * y
⊢ False\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{linarith}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1
hg_cont : Continuous g
x : ℝ
hg_nonlinear : ¬g x = g 1 * x
ε : ℝ
hε : ε > 0 ∧ ∀ (y : ℝ), |y - x| < ε → g y ≠ g 1 * y
⊢ x - ε < x\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{exact hε.2 q (abs_lt.2 ⟨by linarith, by linarith⟩) (by linarith [hg_linear q])}\\
\textbf{Goal:} \begin{verbatim}case h
f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1
hg_cont : Continuous g
x : ℝ
hg_nonlinear : ¬g x = g 1 * x
ε : ℝ
hε : ε > 0 ∧ ∀ (y : ℝ), |y - x| < ε → g y ≠ g 1 * y
q : ℚ
hq₁ : x - ε < ↑q
hq₂ : ↑q < x
⊢ False\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{linarith}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1
hg_cont : Continuous g
x : ℝ
hg_nonlinear : ¬g x = g 1 * x
ε : ℝ
hε : ε > 0 ∧ ∀ (y : ℝ), |y - x| < ε → g y ≠ g 1 * y
q : ℚ
hq₁ : x - ε < ↑q
hq₂ : ↑q < x
⊢ -ε < ↑q - x\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{linarith}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1
hg_cont : Continuous g
x : ℝ
hg_nonlinear : ¬g x = g 1 * x
ε : ℝ
hε : ε > 0 ∧ ∀ (y : ℝ), |y - x| < ε → g y ≠ g 1 * y
q : ℚ
hq₁ : x - ε < ↑q
hq₂ : ↑q < x
⊢ ↑q - x < ε\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{linarith [hg_linear q]}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1
hg_cont : Continuous g
x : ℝ
hg_nonlinear : ¬g x = g 1 * x
ε : ℝ
hε : ε > 0 ∧ ∀ (y : ℝ), |y - x| < ε → g y ≠ g 1 * y
q : ℚ
hq₁ : x - ε < ↑q
hq₂ : ↑q < x
⊢ g ↑q = g 1 * ↑q\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{exact
  ⟨hg_linear.choose, fun x => by
    rw [← hg_linear.choose_spec x, Real.exp_log (div_pos (hf_pos x) (hf_pos 0)),
      mul_div_cancel₀ _ (ne_of_gt (hf_pos 0))]⟩}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_linear : ∃ c, ∀ (x : ℝ), g x = c * x
⊢ ∃ c, ∀ (x : ℝ), f x = f 0 * rexp (c * x)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{rw [← hg_linear.choose_spec x, Real.exp_log (div_pos (hf_pos x) (hf_pos 0)), mul_div_cancel₀ _ (ne_of_gt (hf_pos 0))]}\\
\textbf{Goal:} \begin{verbatim}f : ℝ → ℝ
hf : ExponentialFunctionalEq f
hf_pos : ∀ (x : ℝ), 0 < f x
hf_cont : Continuous f
g : ℝ → ℝ := fun x => log (f x / f 0)
hg_add : ∀ (a b : ℝ), g a + g b = g (a + b)
hg_linear : ∃ c, ∀ (x : ℝ), g x = c * x
x : ℝ
⊢ f x = f 0 * rexp (hg_linear.choose * x)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{exact Finset.sum_pos (fun i _ => Real.exp_pos _) Finset.univ_nonempty}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
β : ℝ
hβ : 0 ≤ β
⊢ 0 < partitionFunction levels β\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{exact div_nonneg (Real.exp_nonneg _) (Finset.sum_nonneg fun _ _ => Real.exp_nonneg _)}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
β : ℝ
hβ : 0 ≤ β
i : Fin w
⊢ 0 ≤ boltzmannProb levels β i\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{have h_sum_def : ∑ i, boltzmannProb levels β i = ∑ i, (Real.exp (-β * levels.ε i) / partitionFunction levels β) := by
  rfl;}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
β : ℝ
hβ : 0 ≤ β
⊢ ∑ i, boltzmannProb levels β i = 1\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{rfl}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
β : ℝ
hβ : 0 ≤ β
⊢ ∑ i, boltzmannProb levels β i = ∑ i, rexp (-β * levels.ε i) / partitionFunction levels β\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{rw [h_sum_def, ← Finset.sum_div]}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
β : ℝ
hβ : 0 ≤ β
h_sum_def : ∑ i, boltzmannProb levels β i = ∑ i, rexp (-β * levels.ε i) / partitionFunction levels β
⊢ ∑ i, boltzmannProb levels β i = 1\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{exact div_self <| ne_of_gt <| partitionFunction_pos levels β hβ}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
β : ℝ
hβ : 0 ≤ β
h_sum_def : ∑ i, boltzmannProb levels β i = ∑ i, rexp (-β * levels.ε i) / partitionFunction levels β
⊢ (∑ i, rexp (-β * levels.ε i)) / partitionFunction levels β = 1\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{sorry}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
p : Fin w → ℝ
hp_pos : ∀ (i : Fin w), 0 < p i
hp_normalized : ∑ i, p i = 1
hp_functional : ∀ (a b : Fin w) (hab : ↑a + ↑b < w), p a * p b = p ⟨0, ⋯⟩ * p ⟨↑a + ↑b, hab⟩
⊢ ∃ β, ∀ (i : Fin w), p i = boltzmannProb levels β i\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{norm_cast}\\
\textbf{Goal:} \begin{verbatim}⊢ ∀ (i : Fin 3), 0 ≤ if ↑i = 0 then 0 else if ↑i = 1 then 1 else 4\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{grind
  /-
  Definition of the counterexample probability distribution and proof that it is positive everywhere.
  -/
  }\\
\textbf{Goal:} \begin{verbatim}⊢ (if ↑⟨0, ⋯⟩ = 0 then 0 else if ↑⟨0, ⋯⟩ = 1 then 1 else 4) = 0\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{intro i}\\
\textbf{Goal:} \begin{verbatim}⊢ ∀ (i : Fin 3), 0 < badP i\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{fin_cases i}\\
\textbf{Goal:} \begin{verbatim}i : Fin 3
⊢ 0 < badP i\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{simp [badP]}\\
\textbf{Goal:} \begin{verbatim}case «0»
⊢ 0 < badP ((fun i => i) ⟨0, ⋯⟩)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{simp [badP]}\\
\textbf{Goal:} \begin{verbatim}case «1»
⊢ 0 < badP ((fun i => i) ⟨1, ⋯⟩)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{simp [badP]}\\
\textbf{Goal:} \begin{verbatim}case «2»
⊢ 0 < badP ((fun i => i) ⟨2, ⋯⟩)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{simp [badP, Fin.sum_univ_three]}\\
\textbf{Goal:} \begin{verbatim}⊢ ∑ i, badP i = 1\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{norm_num
  /-
  Proof that the counterexample satisfies the functional equation.
  -/
  }\\
\textbf{Goal:} \begin{verbatim}⊢ 7⁻¹ + 2 / 7 + 4 / 7 = 1\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{norm_num}\\
\textbf{Goal:} \begin{verbatim}a b : Fin 3
hab : ↑a + ↑b < 3
⊢ 0 < 3\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{unfold badP}\\
\textbf{Goal:} \begin{verbatim}⊢ ∀ (a b : Fin 3) (hab : ↑a + ↑b < 3), badP a * badP b = badP ⟨0, ⋯⟩ * badP ⟨↑a + ↑b, hab⟩\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{norm_num [Fin.forall_fin_succ]}\\
\textbf{Goal:} \begin{verbatim}⊢ ∀ (a b : Fin 3) (hab : ↑a + ↑b < 3),
    ((if ↑a = 0 then 1 / 7 else if ↑a = 1 then 2 / 7 else 4 / 7) *
        if ↑b = 0 then 1 / 7 else if ↑b = 1 then 2 / 7 else 4 / 7) =
      (if ↑⟨0, ⋯⟩ = 0 then 1 / 7 else if ↑⟨0, ⋯⟩ = 1 then 2 / 7 else 4 / 7) *
        if ↑⟨↑a + ↑b, hab⟩ = 0 then 1 / 7 else if ↑⟨↑a + ↑b, hab⟩ = 1 then 2 / 7 else 4 / 7\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{unfold boltzmannProb badP badLevels}\\
\textbf{Goal:} \begin{verbatim}⊢ ¬∃ β, ∀ (i : Fin 3), badP i = boltzmannProb badLevels β i\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{norm_num}\\
\textbf{Goal:} \begin{verbatim}⊢ ¬∃ β,
      ∀ (i : Fin 3),
        (if ↑i = 0 then 1 / 7 else if ↑i = 1 then 2 / 7 else 4 / 7) =
          rexp
              (-β *
                { ε := fun i => if ↑i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := badLevels._proof_4,
                      ε_zero := badLevels._proof_1 }.ε
                  i) /
            partitionFunction
              { ε := fun i => if ↑i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := badLevels._proof_4,
                ε_zero := badLevels._proof_1 }
              β\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{by_contra! h}\\
\textbf{Goal:} \begin{verbatim}⊢ ∀ (x : ℝ),
    ∃ x_1,
      ¬(if x_1 = 0 then 1 / 7 else if ↑x_1 = 1 then 2 / 7 else 4 / 7) =
          rexp (if x_1 = 0 then 0 else if ↑x_1 = 1 then -x else -(x * 4)) /
            partitionFunction { ε := fun i => if i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := ⋯, ε_zero := ⋯ }
              x\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{simp_all +decide [Fin.forall_fin_succ]}\\
\textbf{Goal:} \begin{verbatim}h :
  ∃ x,
    ∀ (x_1 : Fin 3),
      (if x_1 = 0 then 1 / 7 else if ↑x_1 = 1 then 2 / 7 else 4 / 7) =
        rexp (if x_1 = 0 then 0 else if ↑x_1 = 1 then -x else -(x * 4)) /
          partitionFunction { ε := fun i => if i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := ⋯, ε_zero := ⋯ } x
⊢ False\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{norm_num [div_eq_mul_inv, Real.exp_mul, Real.exp_neg] at *}\\
\textbf{Goal:} \begin{verbatim}h :
  ∃ x,
    7 = partitionFunction { ε := fun i => if i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := ⋯, ε_zero := ⋯ } x ∧
      2 / 7 =
          rexp (-x) /
            partitionFunction { ε := fun i => if i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := ⋯, ε_zero := ⋯ }
              x ∧
        4 / 7 =
          rexp (-(x * 4)) /
            partitionFunction { ε := fun i => if i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := ⋯, ε_zero := ⋯ }
              x
⊢ False\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{grind
  /-
  Disproof of the Boltzmann distribution derivation theorem using the counterexample.
  -/
  }\\
\textbf{Goal:} \begin{verbatim}h :
  ∃ x,
    7 = partitionFunction { ε := fun i => if i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := ⋯, ε_zero := ⋯ } x ∧
      2 / 7 =
          (rexp x)⁻¹ *
            (partitionFunction
                { ε := fun i => if i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := ⋯, ε_zero := ⋯ } x)⁻¹ ∧
        4 / 7 =
          (rexp x ^ 4)⁻¹ *
            (partitionFunction
                { ε := fun i => if i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := ⋯, ε_zero := ⋯ } x)⁻¹
⊢ False\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{intro h}\\
\textbf{Goal:} \begin{verbatim}⊢ ¬∀ {w : ℕ} [inst : NeZero w] (levels : EnergyLevels w) (p : Fin w → ℝ),
      (∀ (i : Fin w), 0 < p i) →
        ∑ i, p i = 1 →
          (∀ (a b : Fin w) (hab : ↑a + ↑b < w), p a * p b = p ⟨0, ⋯⟩ * p ⟨↑a + ↑b, hab⟩) →
            ∃ β, ∀ (i : Fin w), p i = boltzmannProb levels β i\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{specialize h badLevels badP badP_pos badP_sum badP_functional}\\
\textbf{Goal:} \begin{verbatim}h :
  ∀ {w : ℕ} [inst : NeZero w] (levels : EnergyLevels w) (p : Fin w → ℝ),
    (∀ (i : Fin w), 0 < p i) →
      ∑ i, p i = 1 →
        (∀ (a b : Fin w) (hab : ↑a + ↑b < w), p a * p b = p ⟨0, ⋯⟩ * p ⟨↑a + ↑b, hab⟩) →
          ∃ β, ∀ (i : Fin w), p i = boltzmannProb levels β i
⊢ False\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{exact badP_not_boltzmann h}\\
\textbf{Goal:} \begin{verbatim}h : ∃ β, ∀ (i : Fin 3), badP i = boltzmannProb badLevels β i
⊢ False\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{negate_state}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
p : Fin w → ℝ
hp_pos : ∀ (i : Fin w), 0 < p i
hp_normalized : ∑ i, p i = 1
hp_functional : ∀ (a b : Fin w) (hab : ↑a + ↑b < w), p a * p b = p ⟨0, ⋯⟩ * p ⟨↑a + ↑b, hab⟩
⊢ ∃ β, ∀ (i : Fin w), p i = boltzmannProb levels β i\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{use 3, by
  -- Show that 3 is a positive natural number.
  infer_instance}\\
\textbf{Goal:} \begin{verbatim}⊢ ∃ w,
    ∃ (h : NeZero w),
      ∃ levels p,
        (∀ (i : Fin w), 0 < p i) ∧
          ∑ i, p i = 1 ∧
            (∀ (a b : Fin w) (hab : ↑a + ↑b < w), p a * p b = p ⟨0, ⋯⟩ * p ⟨↑a + ↑b, hab⟩) ∧
              ∀ (β : ℝ), ∃ i, p i ≠ boltzmannProb levels β i\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{infer_instance}\\
\textbf{Goal:} \begin{verbatim}⊢ NeZero 3\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{generalize_proofs at *}\\
\textbf{Goal:} \begin{verbatim}case h
⊢ ∃ levels p,
    (∀ (i : Fin 3), 0 < p i) ∧
      ∑ i, p i = 1 ∧
        (∀ (a b : Fin 3) (hab : ↑a + ↑b < 3), p a * p b = p ⟨0, ⋯⟩ * p ⟨↑a + ↑b, hab⟩) ∧
          ∀ (β : ℝ), ∃ i, p i ≠ boltzmannProb levels β i\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{generalize_proofs at *}\\
\textbf{Goal:} \begin{verbatim}case h
pf✝¹ : NeZero 3
pf✝ : 0 < 3
⊢ ∃ levels p,
    (∀ (i : Fin 3), 0 < p i) ∧
      ∑ i, p i = 1 ∧
        (∀ (a b : Fin 3) (hab : ↑a + ↑b < 3), p a * p b = p ⟨0, pf✝⟩ * p ⟨↑a + ↑b, hab⟩) ∧
          ∀ (β : ℝ), ∃ i, p i ≠ boltzmannProb levels β i\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{use badLevels, badP}\\
\textbf{Goal:} \begin{verbatim}case h
pf✝¹ : NeZero 3
pf✝ : 0 < 3
⊢ ∃ levels p,
    (∀ (i : Fin 3), 0 < p i) ∧
      ∑ i, p i = 1 ∧
        (∀ (a b : Fin 3) (hab : ↑a + ↑b < 3), p a * p b = p ⟨0, pf✝⟩ * p ⟨↑a + ↑b, hab⟩) ∧
          ∀ (β : ℝ), ∃ i, p i ≠ boltzmannProb levels β i\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{generalize_proofs at *}\\
\textbf{Goal:} \begin{verbatim}case h
pf✝¹ : NeZero 3
pf✝ : 0 < 3
⊢ (∀ (i : Fin 3), 0 < badP i) ∧
    ∑ i, badP i = 1 ∧
      (∀ (a b : Fin 3) (hab : ↑a + ↑b < 3), badP a * badP b = badP ⟨0, pf✝⟩ * badP ⟨↑a + ↑b, hab⟩) ∧
        ∀ (β : ℝ), ∃ i, badP i ≠ boltzmannProb badLevels β i\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{apply
  And.intro (badP_pos)
    (And.intro (badP_sum) (And.intro (badP_functional) (fun x => by by_contra! h; exact badP_not_boltzmann ⟨x, h⟩)))}\\
\textbf{Goal:} \begin{verbatim}case h
pf✝¹ : NeZero 3
pf✝ : 0 < 3
⊢ (∀ (i : Fin 3), 0 < badP i) ∧
    ∑ i, badP i = 1 ∧
      (∀ (a b : Fin 3) (hab : ↑a + ↑b < 3), badP a * badP b = badP ⟨0, pf✝⟩ * badP ⟨↑a + ↑b, hab⟩) ∧
        ∀ (β : ℝ), ∃ i, badP i ≠ boltzmannProb badLevels β i\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{by_contra! h}\\
\textbf{Goal:} \begin{verbatim}pf✝¹ : NeZero 3
pf✝ : 0 < 3
x : ℝ
⊢ ∃ i, badP i ≠ boltzmannProb badLevels x i\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{exact badP_not_boltzmann ⟨x, h⟩}\\
\textbf{Goal:} \begin{verbatim}pf✝¹ : NeZero 3
pf✝ : 0 < 3
x : ℝ
h : ∀ (i : Fin 3), badP i = boltzmannProb badLevels x i
⊢ False\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{exact one_div_pos.mpr hT}\\
\textbf{Goal:} \begin{verbatim}T : ℝ
hT : 0 < T
⊢ 0 < 1 / T\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{exact le_of_lt (one_div_pos.mpr hT)}\\
\textbf{Goal:} \begin{verbatim}T : ℝ
hT : 0 < T
⊢ 0 ≤ 1 / T\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{unfold internalEnergy boltzmannDist}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
⊢ let β := 1 / T;
  let dist := boltzmannDist levels β ⋯;
  internalEnergy levels dist = -deriv (fun β' => log (partitionFunction levels β')) (1 / T)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{generalize_proofs at *}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
⊢ let β := 1 / T;
  let dist := { p := boltzmannProb levels β, p_nonneg := ⋯, p_sum_one := ⋯ };
  ∑ i, dist.p i * levels.ε i = -deriv (fun β' => log (partitionFunction levels β')) (1 / T)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{unfold partitionFunction boltzmannProb}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
pf✝¹ : ∀ (i : Fin w), 0 ≤ boltzmannProb levels (1 / T) i
pf✝ : ∑ i, boltzmannProb levels (1 / T) i = 1
⊢ let β := 1 / T;
  let dist := { p := boltzmannProb levels β, p_nonneg := pf✝¹, p_sum_one := pf✝ };
  ∑ i, dist.p i * levels.ε i = -deriv (fun β' => log (partitionFunction levels β')) (1 / T)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{unfold partitionFunction}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
pf✝¹ : ∀ (i : Fin w), 0 ≤ boltzmannProb levels (1 / T) i
pf✝ : ∑ i, boltzmannProb levels (1 / T) i = 1
⊢ let β := 1 / T;
  let dist := { p := fun i => rexp (-β * levels.ε i) / partitionFunction levels β, p_nonneg := pf✝¹, p_sum_one := pf✝ };
  ∑ i, dist.p i * levels.ε i = -deriv (fun β' => log (∑ i, rexp (-β' * levels.ε i))) (1 / T)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{rw [deriv.log]}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
pf✝¹ : ∀ (i : Fin w), 0 ≤ boltzmannProb levels (1 / T) i
pf✝ : ∑ i, boltzmannProb levels (1 / T) i = 1
⊢ let β := 1 / T;
  let dist :=
    { p := fun i => rexp (-β * levels.ε i) / ∑ i, rexp (-β * levels.ε i), p_nonneg := pf✝¹, p_sum_one := pf✝ };
  ∑ i, dist.p i * levels.ε i = -deriv (fun β' => log (∑ i, rexp (-β' * levels.ε i))) (1 / T)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{norm_num [mul_comm]}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
pf✝¹ : ∀ (i : Fin w), 0 ≤ boltzmannProb levels (1 / T) i
pf✝ : ∑ i, boltzmannProb levels (1 / T) i = 1
⊢ let β := 1 / T;
  let dist :=
    { p := fun i => rexp (-β * levels.ε i) / ∑ i, rexp (-β * levels.ε i), p_nonneg := pf✝¹, p_sum_one := pf✝ };
  ∑ i, dist.p i * levels.ε i =
    -(deriv (fun β' => ∑ i, rexp (-β' * levels.ε i)) (1 / T) / ∑ i, rexp (-(1 / T) * levels.ε i))\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{norm_num [mul_comm]}\\
\textbf{Goal:} \begin{verbatim}case hf
w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
pf✝¹ : ∀ (i : Fin w), 0 ≤ boltzmannProb levels (1 / T) i
pf✝ : ∑ i, boltzmannProb levels (1 / T) i = 1
⊢ DifferentiableAt ℝ (fun β' => ∑ i, rexp (-β' * levels.ε i)) (1 / T)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{norm_num [mul_comm]}\\
\textbf{Goal:} \begin{verbatim}case hx
w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
pf✝¹ : ∀ (i : Fin w), 0 ≤ boltzmannProb levels (1 / T) i
pf✝ : ∑ i, boltzmannProb levels (1 / T) i = 1
⊢ ∑ i, rexp (-(1 / T) * levels.ε i) ≠ 0\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{simp +decide [div_eq_mul_inv, mul_assoc, mul_comm, Finset.mul_sum _ _ _]}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
pf✝¹ : ∀ (i : Fin w), 0 ≤ boltzmannProb levels (1 / T) i
pf✝ : ∑ i, boltzmannProb levels (1 / T) i = 1
⊢ ∑ x, levels.ε x * (rexp (-(T⁻¹ * levels.ε x)) / ∑ x, rexp (-(T⁻¹ * levels.ε x))) =
    -((-∑ x, levels.ε x * rexp (-(T⁻¹ * levels.ε x))) / ∑ x, rexp (-(T⁻¹ * levels.ε x)))\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{exact ne_of_gt <| Finset.sum_pos (fun _ _ => Real.exp_pos _) Finset.univ_nonempty}\\
\textbf{Goal:} \begin{verbatim}case hx
w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
pf✝¹ : ∀ (i : Fin w), 0 ≤ boltzmannProb levels (1 / T) i
pf✝ : ∑ i, boltzmannProb levels (1 / T) i = 1
⊢ ¬∑ x, rexp (-(T⁻¹ * levels.ε x)) = 0\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{rfl}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
⊢ freeEnergy levels T = -T * log (partitionFunction levels (1 / T))\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{have h_gibbs_entropy :
  gibbsEntropy (boltzmannDist levels (1 / T) (one_div_nonneg_of_pos hT)) =
    (1 / T) * (internalEnergy levels (boltzmannDist levels (1 / T) (one_div_nonneg_of_pos hT))) +
      Real.log (partitionFunction levels (1 / T)) :=
  by unfold gibbsEntropy internalEnergy boltzmannDist; simp +decide [boltzmannProb, Finset.mul_sum _ _ _, mul_comm];
  rw [Finset.sum_congr rfl fun i _ => by
      rw [Real.log_div (by positivity)
          (by exact ne_of_gt <| Finset.sum_pos (fun _ _ => Real.exp_pos _) ⟨i, Finset.mem_univ _⟩)]];
  ring_nf; norm_num [mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _];
  simp +decide [← Finset.mul_sum _ _ _, partitionFunction];
  rw [inv_mul_eq_div,
    div_eq_iff (ne_of_gt <| Finset.sum_pos (fun _ _ => Real.exp_pos _) ⟨⟨0, NeZero.pos w⟩, Finset.mem_univ _⟩)];}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
⊢ let β := 1 / T;
  let dist := boltzmannDist levels β ⋯;
  let U := internalEnergy levels dist;
  let S := gibbsEntropy dist;
  let F := freeEnergy levels T;
  U = F + T * S\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{unfold gibbsEntropy internalEnergy boltzmannDist}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
⊢ gibbsEntropy (boltzmannDist levels (1 / T) ⋯) =
    1 / T * internalEnergy levels (boltzmannDist levels (1 / T) ⋯) + log (partitionFunction levels (1 / T))\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{simp +decide [boltzmannProb, Finset.mul_sum _ _ _, mul_comm]}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
⊢ -∑ i,
        { p := boltzmannProb levels (1 / T), p_nonneg := ⋯, p_sum_one := ⋯ }.p i *
          log ({ p := boltzmannProb levels (1 / T), p_nonneg := ⋯, p_sum_one := ⋯ }.p i) =
    1 / T * ∑ i, { p := boltzmannProb levels (1 / T), p_nonneg := ⋯, p_sum_one := ⋯ }.p i * levels.ε i +
      log (partitionFunction levels (1 / T))\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{rw [Finset.sum_congr rfl fun i _ => by
    rw [Real.log_div (by positivity)
        (by exact ne_of_gt <| Finset.sum_pos (fun _ _ => Real.exp_pos _) ⟨i, Finset.mem_univ _⟩)]]}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
⊢ -∑ x,
        rexp (-(T⁻¹ * levels.ε x)) / partitionFunction levels T⁻¹ *
          log (rexp (-(T⁻¹ * levels.ε x)) / partitionFunction levels T⁻¹) =
    ∑ i, T⁻¹ * (levels.ε i * (rexp (-(T⁻¹ * levels.ε i)) / partitionFunction levels T⁻¹)) +
      log (partitionFunction levels T⁻¹)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{rw [Real.log_div (by positivity)
    (by exact ne_of_gt <| Finset.sum_pos (fun _ _ => Real.exp_pos _) ⟨i, Finset.mem_univ _⟩)]}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
i : Fin w
x✝ : i ∈ Finset.univ
⊢ rexp (-(T⁻¹ * levels.ε i)) / partitionFunction levels T⁻¹ *
      log (rexp (-(T⁻¹ * levels.ε i)) / partitionFunction levels T⁻¹) =
    ?m.94 i\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{positivity}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
i : Fin w
x✝ : i ∈ Finset.univ
⊢ rexp (-(T⁻¹ * levels.ε i)) ≠ 0\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{exact ne_of_gt <| Finset.sum_pos (fun _ _ => Real.exp_pos _) ⟨i, Finset.mem_univ _⟩}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
i : Fin w
x✝ : i ∈ Finset.univ
⊢ partitionFunction levels T⁻¹ ≠ 0\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{ring_nf}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
⊢ -∑ i,
        rexp (-(T⁻¹ * levels.ε i)) / partitionFunction levels T⁻¹ *
          (log (rexp (-(T⁻¹ * levels.ε i))) - log (partitionFunction levels T⁻¹)) =
    ∑ i, T⁻¹ * (levels.ε i * (rexp (-(T⁻¹ * levels.ε i)) / partitionFunction levels T⁻¹)) +
      log (partitionFunction levels T⁻¹)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{norm_num [mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _]}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
⊢ -∑ x,
        (rexp (-(T⁻¹ * levels.ε x)) * (partitionFunction levels T⁻¹)⁻¹ * log (rexp (-(T⁻¹ * levels.ε x))) -
          rexp (-(T⁻¹ * levels.ε x)) * (partitionFunction levels T⁻¹)⁻¹ * log (partitionFunction levels T⁻¹)) =
    log (partitionFunction levels T⁻¹) +
      ∑ x, T⁻¹ * (partitionFunction levels T⁻¹)⁻¹ * levels.ε x * rexp (-(T⁻¹ * levels.ε x))\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{simp +decide [← Finset.mul_sum _ _ _, partitionFunction]}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
⊢ ∑ x, (partitionFunction levels T⁻¹)⁻¹ * (log (partitionFunction levels T⁻¹) * rexp (-(T⁻¹ * levels.ε x))) =
    log (partitionFunction levels T⁻¹)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{rw [inv_mul_eq_div,
  div_eq_iff (ne_of_gt <| Finset.sum_pos (fun _ _ => Real.exp_pos _) ⟨⟨0, NeZero.pos w⟩, Finset.mem_univ _⟩)]}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
⊢ (∑ x, rexp (-(T⁻¹ * levels.ε x)))⁻¹ * (log (∑ x, rexp (-(T⁻¹ * levels.ε x))) * ∑ i, rexp (-(T⁻¹ * levels.ε i))) =
    log (∑ x, rexp (-(T⁻¹ * levels.ε x)))\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{simp_all +decide}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
h_gibbs_entropy :
  gibbsEntropy (boltzmannDist levels (1 / T) ⋯) =
    1 / T * internalEnergy levels (boltzmannDist levels (1 / T) ⋯) + log (partitionFunction levels (1 / T))
⊢ let β := 1 / T;
  let dist := boltzmannDist levels β ⋯;
  let U := internalEnergy levels dist;
  let S := gibbsEntropy dist;
  let F := freeEnergy levels T;
  U = F + T * S\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{unfold freeEnergy}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
h_gibbs_entropy :
  gibbsEntropy (boltzmannDist levels T⁻¹ ⋯) =
    T⁻¹ * internalEnergy levels (boltzmannDist levels T⁻¹ ⋯) + log (partitionFunction levels T⁻¹)
⊢ internalEnergy levels (boltzmannDist levels T⁻¹ ⋯) =
    freeEnergy levels T +
      T * (T⁻¹ * internalEnergy levels (boltzmannDist levels T⁻¹ ⋯) + log (partitionFunction levels T⁻¹))\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{ring_nf}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
h_gibbs_entropy :
  gibbsEntropy (boltzmannDist levels T⁻¹ ⋯) =
    T⁻¹ * internalEnergy levels (boltzmannDist levels T⁻¹ ⋯) + log (partitionFunction levels T⁻¹)
⊢ internalEnergy levels (boltzmannDist levels T⁻¹ ⋯) =
    -T * log (partitionFunction levels (1 / T)) +
      T * (T⁻¹ * internalEnergy levels (boltzmannDist levels T⁻¹ ⋯) + log (partitionFunction levels T⁻¹))\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{norm_num [hT.ne']}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
h_gibbs_entropy :
  gibbsEntropy (boltzmannDist levels T⁻¹ ⋯) =
    T⁻¹ * internalEnergy levels (boltzmannDist levels T⁻¹ ⋯) + log (partitionFunction levels T⁻¹)
⊢ internalEnergy levels (boltzmannDist levels T⁻¹ ⋯) = T * T⁻¹ * internalEnergy levels (boltzmannDist levels T⁻¹ ⋯)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{field_simp}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
⊢ let β := 1 / T;
  let dist := boltzmannDist levels β ⋯;
  gibbsEntropy dist = log (partitionFunction levels β) + β * internalEnergy levels dist\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{have := beta_equals_inverse_temperature levels T hT}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
⊢ T * gibbsEntropy (boltzmannDist levels (1 / T) ⋯) =
    T * log (partitionFunction levels (1 / T)) + internalEnergy levels (boltzmannDist levels (1 / T) ⋯)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{unfold freeEnergy at *}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
this :
  let β := 1 / T;
  have dist := boltzmannDist levels β ⋯;
  have U := internalEnergy levels dist;
  have S := gibbsEntropy dist;
  have F := freeEnergy levels T;
  U = F + T * S
⊢ T * gibbsEntropy (boltzmannDist levels (1 / T) ⋯) =
    T * log (partitionFunction levels (1 / T)) + internalEnergy levels (boltzmannDist levels (1 / T) ⋯)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{aesop}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
this :
  let β := 1 / T;
  have dist := boltzmannDist levels β ⋯;
  have U := internalEnergy levels dist;
  have S := gibbsEntropy dist;
  have F := -T * log (partitionFunction levels (1 / T));
  U = F + T * S
⊢ T * gibbsEntropy (boltzmannDist levels (1 / T) ⋯) =
    T * log (partitionFunction levels (1 / T)) + internalEnergy levels (boltzmannDist levels (1 / T) ⋯)\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{have := @beta_equals_inverse_temperature w _ levels T hT}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
⊢ let β := 1 / T;
  let dist := boltzmannDist levels β ⋯;
  freeEnergy levels T = internalEnergy levels dist - T * gibbsEntropy dist\end{verbatim}
\end{tacticblock}

\begin{tacticblock}
\textbf{Tactic:} \texttt{bound}\\
\textbf{Goal:} \begin{verbatim}w : ℕ
inst✝ : NeZero w
levels : EnergyLevels w
T : ℝ
hT : 0 < T
this :
  let β := 1 / T;
  have dist := boltzmannDist levels β ⋯;
  have U := internalEnergy levels dist;
  have S := gibbsEntropy dist;
  have F := freeEnergy levels T;
  U = F + T * S
⊢ let β := 1 / T;
  let dist := boltzmannDist levels β ⋯;
  freeEnergy levels T = internalEnergy levels dist - T * gibbsEntropy dist\end{verbatim}
\end{tacticblock}

