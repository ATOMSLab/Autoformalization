{"tactics":
 [{"usedConstants":
   ["Real",
    "instHDiv",
    "Real.instZero",
    "Real.instDivInvMonoid",
    "HDiv.hDiv",
    "Real.log",
    "DivInvMonoid.toDiv",
    "Zero.toOfNat0",
    "OfNat.ofNat"],
   "tactic": "set g : ℝ → ℝ := fun x => Real.log (f x / f 0)",
   "proofState": 2,
   "pos": {"line": 72, "column": 6},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\n⊢ ∃ c, ∀ (x : ℝ), f x = f 0 * rexp (c * x)",
   "endPos": {"line": 72, "column": 52}},
  {"usedConstants": ["Real", "Real.instAdd", "instHAdd", "HAdd.hAdd", "Eq"],
   "tactic":
   "have hg_add : ∀ a b, g a + g b = g (a + b) := by\n  -- Substitute the definition of $g$ into the equation and use the functional equation $hf$.\n  \n  intros a b\n  simp [g];\n  rw [← Real.log_mul (ne_of_gt (div_pos (hf_pos _) (hf_pos _))) (ne_of_gt (div_pos (hf_pos _) (hf_pos _))),\n    div_mul_div_comm];\n  rw [hf a b]; rw [mul_div_mul_left _ _ (ne_of_gt (hf_pos 0))];\n  -- Since $g$ is continuous and satisfies $g(a) + g(b) = g(a+b)$, it must be linear.\n  ",
   "proofState": 3,
   "pos": {"line": 73, "column": 6},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\n⊢ ∃ c, ∀ (x : ℝ), f x = f 0 * rexp (c * x)",
   "endPos": {"line": 79, "column": 62}},
  {"usedConstants": ["Real"],
   "tactic": "intros a b",
   "proofState": 4,
   "pos": {"line": 75, "column": 8},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\n⊢ ∀ (a b : ℝ), g a + g b = g (a + b)",
   "endPos": {"line": 75, "column": 18}},
  {"usedConstants":
   ["Real", "id", "Real.instAdd", "instHAdd", "HAdd.hAdd", "Eq"],
   "tactic": "simp [g]",
   "proofState": 5,
   "pos": {"line": 76, "column": 8},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\na b : ℝ\n⊢ g a + g b = g (a + b)",
   "endPos": {"line": 76, "column": 16}},
  {"usedConstants":
   ["Eq.mpr",
    "Real.partialOrder",
    "Real",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "GroupWithZero.toDivInvMonoid",
    "DivisionCommMonoid.toDivisionMonoid",
    "MulZeroClass.toMul",
    "Real.instZero",
    "Monoid.toMulOneClass",
    "congrArg",
    "div_mul_div_comm",
    "Real.instDivInvMonoid",
    "DivisionSemiring.toGroupWithZero",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Real.semiring",
    "ne_of_gt",
    "id",
    "MulOne.toMul",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "DivInvMonoid.toMonoid",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "DivisionMonoid.toDivInvMonoid",
    "Real.log",
    "Field.toSemifield",
    "Real.instAdd",
    "instHAdd",
    "MulOneClass.toMulOne",
    "Semifield.toDivisionSemiring",
    "Real.normedCommRing",
    "HAdd.hAdd",
    "Real.instMul",
    "Semifield.toCommGroupWithZero",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "DivInvMonoid.toDiv",
    "Zero.toOfNat0",
    "CommGroupWithZero.toDivisionCommMonoid",
    "PosMulStrictMono.toPosMulReflectLE",
    "div_pos",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "OfNat.ofNat",
    "Eq.symm",
    "Real.instField",
    "Eq",
    "IsStrictOrderedRing.toPosMulStrictMono",
    "Real.log_mul",
    "Real.instPreorder",
    "Real.linearOrder",
    "MulZeroClass.toZero",
    "PosMulReflectLE.toPosMulReflectLT",
    "instHMul",
    "Real.instIsStrictOrderedRing"],
   "tactic":
   "rw [← Real.log_mul (ne_of_gt (div_pos (hf_pos _) (hf_pos _))) (ne_of_gt (div_pos (hf_pos _) (hf_pos _))),\n  div_mul_div_comm]",
   "proofState": 6,
   "pos": {"line": 77, "column": 8},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\na b : ℝ\n⊢ log (f a / f 0) + log (f b / f 0) = log (f (a + b) / f 0)",
   "endPos": {"line": 77, "column": 149}},
  {"usedConstants":
   ["Eq.mpr",
    "Real",
    "instHDiv",
    "HMul.hMul",
    "DivisionCommMonoid.toDivisionMonoid",
    "Real.instZero",
    "Monoid.toMulOneClass",
    "congrArg",
    "Real.instDivInvMonoid",
    "id",
    "MulOne.toMul",
    "HDiv.hDiv",
    "DivInvMonoid.toMonoid",
    "DivisionMonoid.toDivInvMonoid",
    "Real.log",
    "Field.toSemifield",
    "Real.instAdd",
    "instHAdd",
    "MulOneClass.toMulOne",
    "HAdd.hAdd",
    "Real.instMul",
    "Semifield.toCommGroupWithZero",
    "DivInvMonoid.toDiv",
    "Zero.toOfNat0",
    "CommGroupWithZero.toDivisionCommMonoid",
    "OfNat.ofNat",
    "Real.instField",
    "Eq",
    "instHMul"],
   "tactic": "rw [hf a b]",
   "proofState": 7,
   "pos": {"line": 78, "column": 8},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\na b : ℝ\n⊢ log (f a * f b / (f 0 * f 0)) = log (f (a + b) / f 0)",
   "endPos": {"line": 78, "column": 21}},
  {"usedConstants":
   ["Eq.mpr",
    "GroupWithZero.toMonoidWithZero",
    "Real",
    "instHDiv",
    "HMul.hMul",
    "GroupWithZero.toDivInvMonoid",
    "DivisionCommMonoid.toDivisionMonoid",
    "MulZeroClass.toMul",
    "Real.instZero",
    "Monoid.toMulOneClass",
    "congrArg",
    "Real.instDivInvMonoid",
    "ne_of_gt",
    "id",
    "MulOne.toMul",
    "HDiv.hDiv",
    "DivInvMonoid.toMonoid",
    "DivisionMonoid.toDivInvMonoid",
    "Real.log",
    "Field.toSemifield",
    "Real.instAdd",
    "instHAdd",
    "MulOneClass.toMulOne",
    "MonoidWithZero.toMulZeroOneClass",
    "HAdd.hAdd",
    "Real.instMul",
    "Semifield.toCommGroupWithZero",
    "DivInvMonoid.toDiv",
    "mul_div_mul_left",
    "Zero.toOfNat0",
    "Eq.refl",
    "CommGroupWithZero.toDivisionCommMonoid",
    "MulZeroOneClass.toMulZeroClass",
    "CommGroupWithZero.toGroupWithZero",
    "OfNat.ofNat",
    "Real.instField",
    "Eq",
    "Real.instPreorder",
    "MulZeroClass.toZero",
    "instHMul"],
   "tactic": "rw [mul_div_mul_left _ _ (ne_of_gt (hf_pos 0))]",
   "proofState": 8,
   "pos": {"line": 79, "column": 8},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\na b : ℝ\n⊢ log (f 0 * f (a + b) / (f 0 * f 0)) = log (f (a + b) / f 0)",
   "endPos": {"line": 79, "column": 61}},
  {"usedConstants":
   ["Rat.num_div_den",
    "Iff.mpr",
    "AddGroup.toSubtractionMonoid",
    "Real.instIsOrderedRing",
    "Int.cast",
    "Not.intro",
    "Eq.mpr",
    "GroupWithZero.toMonoidWithZero",
    "NegZeroClass.toNeg",
    "NonAssocSemiring.toAddCommMonoidWithOne",
    "Int.cast_natCast",
    "MulOne.toOne",
    "False",
    "Rat.cast_intCast",
    "Real.partialOrder",
    "Semigroup.toMul",
    "Real",
    "Rat.cast_mul",
    "DivInvMonoid.toInv",
    "Rat.num",
    "Mathlib.Meta.NormNum.instAddMonoidWithOne",
    "Preorder.toLT",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "GroupWithZero.toDivisionMonoid",
    "Rat.pos",
    "HMul.hMul",
    "GroupWithZero.toDivInvMonoid",
    "Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt",
    "Int.induction_on",
    "Nat.rawCast",
    "DivInvOneMonoid.toInvOneClass",
    "DivisionRing.toRatCast",
    "eq_false",
    "AddMonoid.toAddSemigroup",
    "mul_inv_cancel₀",
    "Ring.toNonAssocRing",
    "MulZeroClass.toMul",
    "Mathlib.Tactic.Ring.mul_zero",
    "Mathlib.Tactic.Ring.mul_pf_left",
    "Real.instZero",
    "Real.instAddMonoid",
    "Monoid.toMulOneClass",
    "Real.instRCLike",
    "AddGroupWithOne.toAddGroup",
    "Mathlib.Tactic.Ring.add_pf_add_gt",
    "congrArg",
    "CommSemiring.toSemiring",
    "Mathlib.Tactic.Ring.add_overlap_pf_zero",
    "Int.cast_zero",
    "Mathlib.Tactic.Ring.neg_congr",
    "Real.instDivInvMonoid",
    "Mathlib.Tactic.Ring.neg_zero",
    "Mathlib.Tactic.Ring.mul_pf_right",
    "MulZeroClass.zero_mul",
    "AddMonoid.toAddZeroClass",
    "inv_mul_cancel_left₀",
    "Real.instRatCast",
    "Int.rawCast",
    "Rat",
    "mul_assoc",
    "PartialOrder.toPreorder",
    "Mathlib.Tactic.Ring.one_mul",
    "AddGroupWithOne.toAddMonoidWithOne",
    "HSub.hSub",
    "Mathlib.Tactic.Ring.zero_mul",
    "Mathlib.Meta.NormNum.IsNat.of_raw",
    "DivisionSemiring.toGroupWithZero",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Mathlib.Tactic.Ring.instCommSemiringNat",
    "Rat.den",
    "DivisionMonoid.toDivInvOneMonoid",
    "Exists",
    "SemilatticeInf.toPartialOrder",
    "Monoid.toNatPow",
    "Mathlib.Tactic.Ring.cast_zero",
    "DivisionRing.toDivisionSemiring",
    "AddZeroClass.toAddZero",
    "Int.cast_add",
    "DivisionRing.toDivInvMonoid",
    "Real.semiring",
    "Mathlib.Tactic.Ring.neg_mul",
    "Eq.mp",
    "DistribLattice.toLattice",
    "neg_eq_zero",
    "Mathlib.Tactic.Ring.sub_pf",
    "sub_eq_zero_of_eq",
    "Rat.instIntCast",
    "Mathlib.Tactic.Ring.neg_add",
    "id",
    "MulOne.toMul",
    "Distrib.toAdd",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "Int.instNegInt",
    "Rat.cast",
    "DivInvMonoid.toMonoid",
    "AddMonoidWithOne.toNatCast",
    "Int.ofNat",
    "Real.instAddGroup",
    "Rat.instDivisionRing",
    "Ne",
    "DivisionRing.toRing",
    "Real.instRing",
    "SubtractionMonoid.toSubNegZeroMonoid",
    "NonAssocSemiring.toMulZeroOneClass",
    "instOfNatNat",
    "Int",
    "AddCommMonoidWithOne.toAddMonoidWithOne",
    "Mathlib.Tactic.Ring.sub_congr",
    "Mathlib.Meta.NormNum.isNat_ofNat",
    "AddGroupWithOne.toIntCast",
    "Mathlib.Meta.NormNum.isInt_mul",
    "exponential_from_functional_eq._proof_1",
    "Real.log_div_self",
    "Real.commRing",
    "SubNegZeroMonoid.toNegZeroClass",
    "Mathlib.Tactic.Ring.of_eq",
    "Real.instAddCommGroup",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Mathlib.Tactic.Ring.add_pf_zero_add",
    "SubtractionCommMonoid.toSubtractionMonoid",
    "div_eq_mul_inv",
    "Nat.cast",
    "Real.log",
    "Field.toSemifield",
    "NonAssocRing.toNonUnitalNonAssocRing",
    "Mathlib.Tactic.Ring.mul_congr",
    "MulZeroOneClass.toMulOneClass",
    "Real.instAdd",
    "And.casesOn",
    "Real.instOne",
    "LT.lt.ne'",
    "SubNegMonoid.toSub",
    "AddMonoidWithOne.toOne",
    "AddZero.toZero",
    "Mathlib.Tactic.Ring.add_mul",
    "instHAdd",
    "AddSemigroup.toAdd",
    "MulOneClass.toMulOne",
    "And",
    "Mathlib.Tactic.Linarith.sub_neg_of_lt",
    "Mathlib.Tactic.Ring.add_pf_add_zero",
    "Rat.cast_inv",
    "instHSub",
    "Inv.inv",
    "Semifield.toDivisionSemiring",
    "Exists.casesOn",
    "Int.cast_eq_zero._simp_1",
    "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
    "AddGroup.toSubNegMonoid",
    "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
    "MonoidWithZero.toMulZeroOneClass",
    "HPow.hPow",
    "Real.normedCommRing",
    "instOfNat",
    "Distrib.toMul",
    "HAdd.hAdd",
    "Nat.instPreorder",
    "Mathlib.Meta.NormNum.IsInt.to_isNat",
    "pow_one",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Int.instRing",
    "Nat",
    "Real.instMul",
    "And.intro",
    "congr",
    "Rat.instInv",
    "Real.instDivisionRing",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "LT.lt",
    "Nat.instCommSemiring",
    "True",
    "eq_self",
    "Real.instIntCast",
    "Exists.intro",
    "DivInvMonoid.toDiv",
    "Mathlib.Tactic.Linarith.eq_of_eq_of_eq",
    "Mathlib.Tactic.Ring.add_pf_add_lt",
    "of_eq_true",
    "Int.instAdd",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Zero.toOfNat0",
    "Mathlib.Meta.NormNum.isInt_add",
    "Eq.refl",
    "Mathlib.Meta.NormNum.IsInt.of_raw",
    "InvOneClass.toInv",
    "instNatCastInt",
    "instHPow",
    "Nat.cast_zero",
    "Mathlib.Tactic.Ring.cast_pos",
    "AddMonoidWithOne.toAddMonoid",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "Mathlib.Tactic.RingNF.nat_rawCast_1",
    "MulZeroOneClass.toMulZeroClass",
    "CommRing.toRing",
    "mul_one",
    "Mathlib.Tactic.Ring.atom_pf",
    "AddCommGroup.toDivisionAddCommMonoid",
    "add_zero",
    "Int.instCharZero",
    "OfNat.ofNat",
    "Eq.symm",
    "not_false_eq_true",
    "Real.instSemigroup",
    "NegZeroClass.toZero",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "Mathlib.Tactic.Linarith.lt_of_eq_of_lt",
    "Nat.cast_one",
    "RCLike.charZero_rclike",
    "Mathlib.Tactic.Ring.neg_one_mul",
    "Ring.toAddGroupWithOne",
    "Not",
    "Mathlib.Tactic.Linarith.lt_irrefl",
    "Rat.instDiv",
    "instDistribLatticeOfLinearOrder",
    "Neg.neg",
    "Real.instPreorder",
    "one_mul",
    "Int.cast_one",
    "MonoidWithZero.toMonoid",
    "Mathlib.Tactic.Ring.mul_add",
    "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
    "Real.linearOrder",
    "Nat.cast_ne_zero",
    "Eq.trans",
    "Int.negOfNat",
    "Rat.instNatCast",
    "MulZeroClass.toZero",
    "Lattice.toSemilatticeInf",
    "Mathlib.Tactic.Ring.add_congr",
    "Real.instCommSemiring",
    "Mathlib.Meta.NormNum.IsNat.to_isInt",
    "Semiring.toMonoidWithZero",
    "instHMul",
    "Real.instNatCast"],
   "tactic":
   "have hg_linear : ∃ c : ℝ, ∀ x, g x = c * x :=\n  by\n  have hg_linear : ∀ q : ℚ, g q = q * g 1 := by\n    -- By induction on $n$, we can show that $g(nx) = ng(x)$ for any integer $n$.\n    \n    have hg_int : ∀ n : ℤ, ∀ x : ℝ, g (n * x) = n * g x := by\n      -- We'll use induction on $n$ to show that $g(nx) = ng(x)$ for any integer $n$.\n      \n      intros n x\n      induction' n using Int.induction_on with n ih; · simp +zetaDelta at *;\n      · have := hg_add (n * x) x; push_cast at *; ring_nf at *; linarith;\n      · grind;\n        -- By definition of rational numbers, for any rational number $q$, we can write $q = \\frac{m}{n}$ where $m$ and $n$ are integers.\n        \n    intro q\n    obtain ⟨m, n, hn_ne_zero, hq⟩ : ∃ m n : ℤ, n ≠ 0 ∧ q = m / n := by\n      exact ⟨q.num, q.den, Nat.cast_ne_zero.mpr q.pos.ne', q.num_div_den.symm⟩;\n    have := hg_int n (1 / n); simp_all +decide [div_eq_mul_inv, mul_assoc];\n    -- Since $g$ is continuous and linear over the rationals, it must be linear over the reals.\n    \n  have hg_cont : Continuous g := by\n    exact Continuous.log (hf_cont.div_const _) fun x => ne_of_gt (div_pos (hf_pos x) (hf_pos 0));\n  use g 1; intros x\n  by_contra hg_nonlinear;\n  -- Since $g$ is continuous and $g(x) \\neq g(1) * x$, there exists a neighborhood around $x$ where $g$ does not take the form $g(1) * x$.\n  obtain ⟨ε, hε⟩ : ∃ ε > 0, ∀ y, abs (y - x) < ε → g y ≠ g 1 * y := by\n    exact\n      Metric.mem_nhds_iff.mp\n        (IsOpen.mem_nhds (isOpen_compl_iff.mpr <| isClosed_eq hg_cont <| continuous_const.mul continuous_id')\n          hg_nonlinear);\n  rcases exists_rat_btwn (show x - ε < x by linarith) with ⟨q, hq₁, hq₂⟩;\n  exact hε.2 q (abs_lt.2 ⟨by linarith, by linarith⟩) (by linarith [hg_linear q]);",
   "proofState": 9,
   "pos": {"line": 81, "column": 6},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\n⊢ ∃ c, ∀ (x : ℝ), f x = f 0 * rexp (c * x)",
   "endPos": {"line": 105, "column": 172}},
  {"usedConstants":
   ["Iff.mpr",
    "AddGroup.toSubtractionMonoid",
    "Real.instIsOrderedRing",
    "Int.cast",
    "Not.intro",
    "Eq.mpr",
    "NegZeroClass.toNeg",
    "NonAssocSemiring.toAddCommMonoidWithOne",
    "Int.cast_natCast",
    "Real.partialOrder",
    "Real",
    "Mathlib.Meta.NormNum.instAddMonoidWithOne",
    "Preorder.toLT",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt",
    "Int.induction_on",
    "Nat.rawCast",
    "AddMonoid.toAddSemigroup",
    "Ring.toNonAssocRing",
    "Mathlib.Tactic.Ring.mul_zero",
    "Mathlib.Tactic.Ring.mul_pf_left",
    "Real.instZero",
    "Real.instAddMonoid",
    "AddGroupWithOne.toAddGroup",
    "Mathlib.Tactic.Ring.add_pf_add_gt",
    "congrArg",
    "CommSemiring.toSemiring",
    "Mathlib.Tactic.Ring.add_overlap_pf_zero",
    "Int.cast_zero",
    "Mathlib.Tactic.Ring.neg_congr",
    "Real.instDivInvMonoid",
    "Mathlib.Tactic.Ring.neg_zero",
    "Mathlib.Tactic.Ring.mul_pf_right",
    "MulZeroClass.zero_mul",
    "AddMonoid.toAddZeroClass",
    "Real.instRatCast",
    "Int.rawCast",
    "Rat",
    "PartialOrder.toPreorder",
    "Mathlib.Tactic.Ring.one_mul",
    "AddGroupWithOne.toAddMonoidWithOne",
    "HSub.hSub",
    "Mathlib.Tactic.Ring.zero_mul",
    "Mathlib.Meta.NormNum.IsNat.of_raw",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Mathlib.Tactic.Ring.instCommSemiringNat",
    "SemilatticeInf.toPartialOrder",
    "Monoid.toNatPow",
    "Mathlib.Tactic.Ring.cast_zero",
    "Int.cast_add",
    "Real.semiring",
    "Mathlib.Tactic.Ring.neg_mul",
    "Eq.mp",
    "DistribLattice.toLattice",
    "neg_eq_zero",
    "Mathlib.Tactic.Ring.sub_pf",
    "sub_eq_zero_of_eq",
    "Mathlib.Tactic.Ring.neg_add",
    "id",
    "Distrib.toAdd",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "Int.instNegInt",
    "Rat.cast",
    "AddMonoidWithOne.toNatCast",
    "Int.ofNat",
    "Real.instAddGroup",
    "Real.instRing",
    "SubtractionMonoid.toSubNegZeroMonoid",
    "NonAssocSemiring.toMulZeroOneClass",
    "instOfNatNat",
    "Int",
    "AddCommMonoidWithOne.toAddMonoidWithOne",
    "Mathlib.Tactic.Ring.sub_congr",
    "Mathlib.Meta.NormNum.isNat_ofNat",
    "AddGroupWithOne.toIntCast",
    "Mathlib.Meta.NormNum.isInt_mul",
    "exponential_from_functional_eq._proof_1",
    "Real.log_div_self",
    "Real.commRing",
    "SubNegZeroMonoid.toNegZeroClass",
    "Mathlib.Tactic.Ring.of_eq",
    "Real.instAddCommGroup",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Mathlib.Tactic.Ring.add_pf_zero_add",
    "SubtractionCommMonoid.toSubtractionMonoid",
    "Nat.cast",
    "Real.log",
    "NonAssocRing.toNonUnitalNonAssocRing",
    "Mathlib.Tactic.Ring.mul_congr",
    "MulZeroOneClass.toMulOneClass",
    "Real.instAdd",
    "Real.instOne",
    "SubNegMonoid.toSub",
    "AddMonoidWithOne.toOne",
    "Mathlib.Tactic.Ring.add_mul",
    "instHAdd",
    "AddSemigroup.toAdd",
    "Mathlib.Tactic.Linarith.sub_neg_of_lt",
    "Mathlib.Tactic.Ring.add_pf_add_zero",
    "instHSub",
    "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
    "AddGroup.toSubNegMonoid",
    "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
    "HPow.hPow",
    "Real.normedCommRing",
    "instOfNat",
    "Distrib.toMul",
    "HAdd.hAdd",
    "Mathlib.Meta.NormNum.IsInt.to_isNat",
    "pow_one",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Nat",
    "Real.instMul",
    "congr",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "LT.lt",
    "Nat.instCommSemiring",
    "True",
    "eq_self",
    "Real.instIntCast",
    "DivInvMonoid.toDiv",
    "Mathlib.Tactic.Linarith.eq_of_eq_of_eq",
    "Mathlib.Tactic.Ring.add_pf_add_lt",
    "of_eq_true",
    "Int.instAdd",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Zero.toOfNat0",
    "Mathlib.Meta.NormNum.isInt_add",
    "Eq.refl",
    "Mathlib.Meta.NormNum.IsInt.of_raw",
    "instNatCastInt",
    "instHPow",
    "Nat.cast_zero",
    "Mathlib.Tactic.Ring.cast_pos",
    "AddMonoidWithOne.toAddMonoid",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "Mathlib.Tactic.RingNF.nat_rawCast_1",
    "CommRing.toRing",
    "mul_one",
    "Mathlib.Tactic.Ring.atom_pf",
    "AddCommGroup.toDivisionAddCommMonoid",
    "add_zero",
    "OfNat.ofNat",
    "NegZeroClass.toZero",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "Mathlib.Tactic.Linarith.lt_of_eq_of_lt",
    "Nat.cast_one",
    "Mathlib.Tactic.Ring.neg_one_mul",
    "Ring.toAddGroupWithOne",
    "Mathlib.Tactic.Linarith.lt_irrefl",
    "instDistribLatticeOfLinearOrder",
    "Neg.neg",
    "Real.instPreorder",
    "Int.cast_one",
    "MonoidWithZero.toMonoid",
    "Mathlib.Tactic.Ring.mul_add",
    "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
    "Real.linearOrder",
    "Eq.trans",
    "Int.negOfNat",
    "MulZeroClass.toZero",
    "Lattice.toSemilatticeInf",
    "Mathlib.Tactic.Ring.add_congr",
    "Real.instCommSemiring",
    "Mathlib.Meta.NormNum.IsNat.to_isInt",
    "Semiring.toMonoidWithZero",
    "instHMul",
    "Real.instNatCast"],
   "tactic":
   "have hg_linear : ∀ q : ℚ, g q = q * g 1 := by\n  -- By induction on $n$, we can show that $g(nx) = ng(x)$ for any integer $n$.\n  \n  have hg_int : ∀ n : ℤ, ∀ x : ℝ, g (n * x) = n * g x := by\n    -- We'll use induction on $n$ to show that $g(nx) = ng(x)$ for any integer $n$.\n    \n    intros n x\n    induction' n using Int.induction_on with n ih; · simp +zetaDelta at *;\n    · have := hg_add (n * x) x; push_cast at *; ring_nf at *; linarith;\n    · grind;\n      -- By definition of rational numbers, for any rational number $q$, we can write $q = \\frac{m}{n}$ where $m$ and $n$ are integers.\n      \n  intro q\n  obtain ⟨m, n, hn_ne_zero, hq⟩ : ∃ m n : ℤ, n ≠ 0 ∧ q = m / n := by\n    exact ⟨q.num, q.den, Nat.cast_ne_zero.mpr q.pos.ne', q.num_div_den.symm⟩;\n  have := hg_int n (1 / n); simp_all +decide [div_eq_mul_inv, mul_assoc];\n  -- Since $g$ is continuous and linear over the rationals, it must be linear over the reals.\n  ",
   "proofState": 10,
   "pos": {"line": 82, "column": 8},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\n⊢ ∃ c, ∀ (x : ℝ), g x = c * x",
   "endPos": {"line": 95, "column": 87}},
  {"usedConstants":
   ["Int.cast",
    "Real",
    "HMul.hMul",
    "Int",
    "Real.instMul",
    "Real.instIntCast",
    "Eq",
    "instHMul"],
   "tactic":
   "have hg_int : ∀ n : ℤ, ∀ x : ℝ, g (n * x) = n * g x := by\n  -- We'll use induction on $n$ to show that $g(nx) = ng(x)$ for any integer $n$.\n  \n  intros n x\n  induction' n using Int.induction_on with n ih; · simp +zetaDelta at *;\n  · have := hg_add (n * x) x; push_cast at *; ring_nf at *; linarith;\n  · grind;\n    -- By definition of rational numbers, for any rational number $q$, we can write $q = \\frac{m}{n}$ where $m$ and $n$ are integers.\n    ",
   "proofState": 11,
   "pos": {"line": 84, "column": 10},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\n⊢ ∀ (q : ℚ), g ↑q = ↑q * g 1",
   "endPos": {"line": 90, "column": 20}},
  {"usedConstants": ["Real", "Int"],
   "tactic": "intros n x",
   "proofState": 12,
   "pos": {"line": 86, "column": 12},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\n⊢ ∀ (n : ℤ) (x : ℝ), g (↑n * x) = ↑n * g x",
   "endPos": {"line": 86, "column": 22}},
  {"usedConstants":
   ["Int.cast",
    "Real",
    "HMul.hMul",
    "Int.induction_on",
    "Int.instNegInt",
    "Int",
    "Nat.cast",
    "Nat",
    "Real.instMul",
    "Real.instIntCast",
    "instNatCastInt",
    "Eq",
    "Neg.neg",
    "instHMul"],
   "tactic": "induction' n using Int.induction_on with n ih",
   "proofState": 13,
   "pos": {"line": 87, "column": 12},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nn : ℤ\nx : ℝ\n⊢ g (↑n * x) = ↑n * g x",
   "endPos": {"line": 87, "column": 57}},
  {"usedConstants":
   ["AddGroup.toSubtractionMonoid",
    "Int.cast",
    "Real",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "Real.instZero",
    "AddGroupWithOne.toAddGroup",
    "congrArg",
    "Int.cast_zero",
    "Real.instDivInvMonoid",
    "MulZeroClass.zero_mul",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "Real.instRing",
    "SubtractionMonoid.toSubNegZeroMonoid",
    "Int",
    "AddGroupWithOne.toIntCast",
    "Real.log_div_self",
    "SubNegZeroMonoid.toNegZeroClass",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Real.log",
    "Real.normedCommRing",
    "instOfNat",
    "Real.instMul",
    "congr",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "True",
    "eq_self",
    "DivInvMonoid.toDiv",
    "of_eq_true",
    "Zero.toOfNat0",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "OfNat.ofNat",
    "NegZeroClass.toZero",
    "Eq",
    "Ring.toAddGroupWithOne",
    "Eq.trans",
    "MulZeroClass.toZero",
    "instHMul"],
   "tactic": "simp +zetaDelta at *",
   "proofState": 14,
   "pos": {"line": 88, "column": 14},
   "goals":
   "case zero\nf : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nx : ℝ\n⊢ g (↑0 * x) = ↑0 * g x",
   "endPos": {"line": 88, "column": 34}},
  {"usedConstants":
   ["Real",
    "HMul.hMul",
    "Nat.cast",
    "Real.instAdd",
    "instHAdd",
    "HAdd.hAdd",
    "Real.instMul",
    "Eq",
    "instHMul",
    "Real.instNatCast"],
   "tactic": "have := hg_add (n * x) x",
   "proofState": 15,
   "pos": {"line": 89, "column": 14},
   "goals":
   "case succ\nf : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nx : ℝ\nn : ℕ\nih : g (↑↑n * x) = ↑↑n * g x\n⊢ g (↑(↑n + 1) * x) = ↑(↑n + 1) * g x",
   "endPos": {"line": 89, "column": 40}},
  {"usedConstants":
   ["Int.cast",
    "Eq.mpr",
    "Int.cast_natCast",
    "Real",
    "HMul.hMul",
    "AddMonoid.toAddSemigroup",
    "congrArg",
    "AddGroupWithOne.toAddMonoidWithOne",
    "Int.cast_add",
    "Eq.mp",
    "id",
    "AddMonoidWithOne.toNatCast",
    "Real.instRing",
    "Int",
    "AddGroupWithOne.toIntCast",
    "Nat.cast",
    "AddMonoidWithOne.toOne",
    "instHAdd",
    "AddSemigroup.toAdd",
    "instOfNat",
    "HAdd.hAdd",
    "Real.instMul",
    "congr",
    "Real.instIntCast",
    "Int.instAdd",
    "One.toOfNat1",
    "instNatCastInt",
    "AddMonoidWithOne.toAddMonoid",
    "OfNat.ofNat",
    "Eq",
    "Ring.toAddGroupWithOne",
    "Int.cast_one",
    "Eq.trans",
    "instHMul"],
   "tactic": "push_cast at *",
   "proofState": 16,
   "pos": {"line": 89, "column": 42},
   "goals":
   "case succ\nf : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nx : ℝ\nn : ℕ\nih : g (↑↑n * x) = ↑↑n * g x\nthis : g (↑n * x) + g x = g (↑n * x + x)\n⊢ g (↑(↑n + 1) * x) = ↑(↑n + 1) * g x",
   "endPos": {"line": 89, "column": 56}},
  {"usedConstants":
   ["Eq.mpr",
    "NonAssocSemiring.toAddCommMonoidWithOne",
    "Real",
    "HMul.hMul",
    "Nat.rawCast",
    "AddMonoid.toAddSemigroup",
    "Mathlib.Tactic.Ring.mul_zero",
    "Mathlib.Tactic.Ring.mul_pf_left",
    "Real.instAddMonoid",
    "Mathlib.Tactic.Ring.add_pf_add_gt",
    "congrArg",
    "CommSemiring.toSemiring",
    "Mathlib.Tactic.Ring.mul_pf_right",
    "AddMonoid.toAddZeroClass",
    "Mathlib.Tactic.Ring.one_mul",
    "AddGroupWithOne.toAddMonoidWithOne",
    "Mathlib.Tactic.Ring.zero_mul",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Mathlib.Tactic.Ring.instCommSemiringNat",
    "Monoid.toNatPow",
    "Real.semiring",
    "Eq.mp",
    "id",
    "Distrib.toAdd",
    "AddMonoidWithOne.toNatCast",
    "Real.instRing",
    "NonAssocSemiring.toMulZeroOneClass",
    "instOfNatNat",
    "AddCommMonoidWithOne.toAddMonoidWithOne",
    "Mathlib.Meta.NormNum.isNat_ofNat",
    "Nat.cast",
    "Mathlib.Tactic.Ring.mul_congr",
    "MulZeroOneClass.toMulOneClass",
    "Real.instAdd",
    "AddMonoidWithOne.toOne",
    "Mathlib.Tactic.Ring.add_mul",
    "instHAdd",
    "AddSemigroup.toAdd",
    "Mathlib.Tactic.Ring.add_pf_add_zero",
    "HPow.hPow",
    "Distrib.toMul",
    "HAdd.hAdd",
    "pow_one",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Nat",
    "Real.instMul",
    "congr",
    "Nat.instCommSemiring",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Zero.toOfNat0",
    "instHPow",
    "Mathlib.Tactic.Ring.cast_pos",
    "AddMonoidWithOne.toAddMonoid",
    "Mathlib.Tactic.RingNF.nat_rawCast_1",
    "mul_one",
    "Mathlib.Tactic.Ring.atom_pf",
    "add_zero",
    "OfNat.ofNat",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "Nat.cast_one",
    "Ring.toAddGroupWithOne",
    "MonoidWithZero.toMonoid",
    "Mathlib.Tactic.Ring.mul_add",
    "Eq.trans",
    "MulZeroClass.toZero",
    "Mathlib.Tactic.Ring.add_congr",
    "Real.instCommSemiring",
    "Semiring.toMonoidWithZero",
    "instHMul",
    "Real.instNatCast"],
   "tactic": "ring_nf at *",
   "proofState": 17,
   "pos": {"line": 89, "column": 58},
   "goals":
   "case succ\nf : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nx : ℝ\nn : ℕ\nthis : g (↑n * x) + g x = g (↑n * x + x)\nih : g (↑n * x) = ↑n * g x\n⊢ g ((↑n + 1) * x) = (↑n + 1) * g x",
   "endPos": {"line": 89, "column": 70}},
  {"usedConstants":
   ["Not.intro",
    "Real",
    "Preorder.toLT",
    "HMul.hMul",
    "Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt",
    "CommSemiring.toSemiring",
    "PartialOrder.toPreorder",
    "AddGroupWithOne.toAddMonoidWithOne",
    "SemilatticeInf.toPartialOrder",
    "DistribLattice.toLattice",
    "Distrib.toAdd",
    "AddMonoidWithOne.toNatCast",
    "Real.instRing",
    "Nat.cast",
    "instHAdd",
    "Distrib.toMul",
    "HAdd.hAdd",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "LT.lt",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Semiring.toNonAssocSemiring",
    "Ring.toAddGroupWithOne",
    "instDistribLatticeOfLinearOrder",
    "Real.linearOrder",
    "Lattice.toSemilatticeInf",
    "Real.instCommSemiring",
    "instHMul"],
   "tactic": "linarith",
   "proofState": 18,
   "pos": {"line": 89, "column": 72},
   "goals":
   "case succ\nf : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nx : ℝ\nn : ℕ\nih : g (↑n * x) = ↑n * g x\nthis : g x + g (↑n * x) = g (↑n * x + x)\n⊢ g (↑n * x + x) = ↑n * g x + g x",
   "endPos": {"line": 89, "column": 80}},
  {"usedConstants": ["exponential_from_functional_eq._proof_1"],
   "tactic": "grind",
   "proofState": 19,
   "pos": {"line": 90, "column": 14},
   "goals":
   "case pred\nf : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nx : ℝ\ni✝ : ℕ\na✝ : g (↑(-↑i✝) * x) = ↑(-↑i✝) * g x\n⊢ g (↑(-↑i✝ - 1) * x) = ↑(-↑i✝ - 1) * g x",
   "endPos": {"line": 90, "column": 19}},
  {"usedConstants": ["Rat"],
   "tactic": "intro q",
   "proofState": 20,
   "pos": {"line": 92, "column": 10},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_int : ∀ (n : ℤ) (x : ℝ), g (↑n * x) = ↑n * g x\n⊢ ∀ (q : ℚ), g ↑q = ↑q * g 1",
   "endPos": {"line": 92, "column": 17}},
  {"usedConstants":
   ["Rat.num_div_den",
    "Iff.mpr",
    "Int.cast",
    "Rat.num",
    "instHDiv",
    "Rat.pos",
    "AddMonoid.toAddZeroClass",
    "Rat",
    "AddGroupWithOne.toAddMonoidWithOne",
    "Rat.den",
    "Exists",
    "AddZeroClass.toAddZero",
    "Rat.instIntCast",
    "HDiv.hDiv",
    "AddMonoidWithOne.toNatCast",
    "Ne",
    "instOfNatNat",
    "Int",
    "Nat.cast",
    "LT.lt.ne'",
    "AddZero.toZero",
    "And",
    "instOfNat",
    "Nat.instPreorder",
    "Int.instRing",
    "Nat",
    "And.intro",
    "Exists.intro",
    "Zero.toOfNat0",
    "instNatCastInt",
    "AddMonoidWithOne.toAddMonoid",
    "Int.instCharZero",
    "OfNat.ofNat",
    "Eq.symm",
    "Eq",
    "Ring.toAddGroupWithOne",
    "Rat.instDiv",
    "Nat.cast_ne_zero",
    "Rat.instNatCast"],
   "tactic":
   "obtain ⟨m, n, hn_ne_zero, hq⟩ : ∃ m n : ℤ, n ≠ 0 ∧ q = m / n := by\n  exact ⟨q.num, q.den, Nat.cast_ne_zero.mpr q.pos.ne', q.num_div_den.symm⟩;",
   "proofState": 21,
   "pos": {"line": 93, "column": 10},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_int : ∀ (n : ℤ) (x : ℝ), g (↑n * x) = ↑n * g x\nq : ℚ\n⊢ g ↑q = ↑q * g 1",
   "endPos": {"line": 94, "column": 87}},
  {"usedConstants":
   ["Rat.num_div_den",
    "Iff.mpr",
    "Int.cast",
    "Rat.num",
    "instHDiv",
    "Rat.pos",
    "AddMonoid.toAddZeroClass",
    "Rat",
    "AddGroupWithOne.toAddMonoidWithOne",
    "Rat.den",
    "Exists",
    "AddZeroClass.toAddZero",
    "Rat.instIntCast",
    "HDiv.hDiv",
    "AddMonoidWithOne.toNatCast",
    "Ne",
    "instOfNatNat",
    "Int",
    "Nat.cast",
    "LT.lt.ne'",
    "AddZero.toZero",
    "And",
    "instOfNat",
    "Nat.instPreorder",
    "Int.instRing",
    "Nat",
    "And.intro",
    "Exists.intro",
    "Zero.toOfNat0",
    "instNatCastInt",
    "AddMonoidWithOne.toAddMonoid",
    "Int.instCharZero",
    "OfNat.ofNat",
    "Eq.symm",
    "Eq",
    "Ring.toAddGroupWithOne",
    "Rat.instDiv",
    "Nat.cast_ne_zero",
    "Rat.instNatCast"],
   "tactic":
   "exact ⟨q.num, q.den, Nat.cast_ne_zero.mpr q.pos.ne', q.num_div_den.symm⟩",
   "proofState": 22,
   "pos": {"line": 94, "column": 12},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_int : ∀ (n : ℤ) (x : ℝ), g (↑n * x) = ↑n * g x\nq : ℚ\n⊢ ∃ m n, n ≠ 0 ∧ q = ↑m / ↑n",
   "endPos": {"line": 94, "column": 86}},
  {"usedConstants":
   ["Int.cast",
    "Real",
    "instHDiv",
    "HMul.hMul",
    "Real.instDivInvMonoid",
    "HDiv.hDiv",
    "Real.instOne",
    "Real.instMul",
    "Real.instIntCast",
    "DivInvMonoid.toDiv",
    "One.toOfNat1",
    "OfNat.ofNat",
    "Eq",
    "instHMul"],
   "tactic": "have := hg_int n (1 / n)",
   "proofState": 23,
   "pos": {"line": 95, "column": 10},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_int : ∀ (n : ℤ) (x : ℝ), g (↑n * x) = ↑n * g x\nq : ℚ\nm n : ℤ\nhn_ne_zero : n ≠ 0\nhq : q = ↑m / ↑n\n⊢ g ↑q = ↑q * g 1",
   "endPos": {"line": 95, "column": 36}},
  {"usedConstants":
   ["AddGroup.toSubtractionMonoid",
    "Int.cast",
    "GroupWithZero.toMonoidWithZero",
    "MulOne.toOne",
    "False",
    "Rat.cast_intCast",
    "Semigroup.toMul",
    "Real",
    "Rat.cast_mul",
    "DivInvMonoid.toInv",
    "instHDiv",
    "GroupWithZero.toDivisionMonoid",
    "HMul.hMul",
    "GroupWithZero.toDivInvMonoid",
    "DivInvOneMonoid.toInvOneClass",
    "DivisionRing.toRatCast",
    "eq_false",
    "mul_inv_cancel₀",
    "Ring.toNonAssocRing",
    "MulZeroClass.toMul",
    "Monoid.toMulOneClass",
    "Real.instRCLike",
    "AddGroupWithOne.toAddGroup",
    "congrArg",
    "Real.instDivInvMonoid",
    "inv_mul_cancel_left₀",
    "Real.instRatCast",
    "Rat",
    "mul_assoc",
    "DivisionSemiring.toGroupWithZero",
    "DivisionMonoid.toDivInvOneMonoid",
    "DivisionRing.toDivisionSemiring",
    "DivisionRing.toDivInvMonoid",
    "Real.semiring",
    "Eq.mp",
    "Rat.instIntCast",
    "id",
    "MulOne.toMul",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "Rat.cast",
    "DivInvMonoid.toMonoid",
    "Rat.instDivisionRing",
    "DivisionRing.toRing",
    "Real.instRing",
    "SubtractionMonoid.toSubNegZeroMonoid",
    "NonAssocSemiring.toMulZeroOneClass",
    "Int",
    "AddGroupWithOne.toIntCast",
    "SubNegZeroMonoid.toNegZeroClass",
    "div_eq_mul_inv",
    "Field.toSemifield",
    "NonAssocRing.toNonUnitalNonAssocRing",
    "MulZeroOneClass.toMulOneClass",
    "Real.instOne",
    "MulOneClass.toMulOne",
    "Rat.cast_inv",
    "Inv.inv",
    "Semifield.toDivisionSemiring",
    "Int.cast_eq_zero._simp_1",
    "MonoidWithZero.toMulZeroOneClass",
    "instOfNat",
    "Distrib.toMul",
    "Real.instMul",
    "congr",
    "Rat.instInv",
    "Real.instDivisionRing",
    "True",
    "eq_self",
    "Real.instIntCast",
    "DivInvMonoid.toDiv",
    "of_eq_true",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Zero.toOfNat0",
    "InvOneClass.toInv",
    "MulZeroOneClass.toMulZeroClass",
    "OfNat.ofNat",
    "not_false_eq_true",
    "Real.instSemigroup",
    "NegZeroClass.toZero",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "RCLike.charZero_rclike",
    "Ring.toAddGroupWithOne",
    "Not",
    "Rat.instDiv",
    "one_mul",
    "Eq.trans",
    "instHMul"],
   "tactic": "simp_all +decide [div_eq_mul_inv, mul_assoc]",
   "proofState": 24,
   "pos": {"line": 95, "column": 39},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_int : ∀ (n : ℤ) (x : ℝ), g (↑n * x) = ↑n * g x\nq : ℚ\nm n : ℤ\nhn_ne_zero : n ≠ 0\nhq : q = ↑m / ↑n\nthis : g (↑n * (1 / ↑n)) = ↑n * g (1 / ↑n)\n⊢ g ↑q = ↑q * g 1",
   "endPos": {"line": 95, "column": 85}},
  {"usedConstants":
   ["Continuous.log",
    "Real.partialOrder",
    "Real",
    "Continuous",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "IsTopologicalRing.toIsTopologicalSemiring",
    "MulZeroClass.toMul",
    "Real.instZero",
    "IsTopologicalSemiring.toContinuousMul",
    "Real.instDivInvMonoid",
    "PseudoMetricSpace.toUniformSpace",
    "DivisionSemiring.toGroupWithZero",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Real.semiring",
    "instIsTopologicalRingReal",
    "ne_of_gt",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Field.toSemifield",
    "Continuous.div_const",
    "Semifield.toDivisionSemiring",
    "Real.normedCommRing",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "DivInvMonoid.toDiv",
    "Semiring.toNonUnitalSemiring",
    "Zero.toOfNat0",
    "PosMulStrictMono.toPosMulReflectLE",
    "Real.pseudoMetricSpace",
    "div_pos",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "OfNat.ofNat",
    "UniformSpace.toTopologicalSpace",
    "Real.instField",
    "IsStrictOrderedRing.toPosMulStrictMono",
    "Real.instPreorder",
    "Real.linearOrder",
    "MulZeroClass.toZero",
    "PosMulReflectLE.toPosMulReflectLT",
    "Real.instIsStrictOrderedRing"],
   "tactic":
   "have hg_cont : Continuous g := by\n  exact Continuous.log (hf_cont.div_const _) fun x => ne_of_gt (div_pos (hf_pos x) (hf_pos 0));",
   "proofState": 25,
   "pos": {"line": 97, "column": 8},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1\n⊢ ∃ c, ∀ (x : ℝ), g x = c * x",
   "endPos": {"line": 98, "column": 111}},
  {"usedConstants":
   ["Continuous.log",
    "Real.partialOrder",
    "Real",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "IsTopologicalRing.toIsTopologicalSemiring",
    "MulZeroClass.toMul",
    "Real.instZero",
    "IsTopologicalSemiring.toContinuousMul",
    "Real.instDivInvMonoid",
    "PseudoMetricSpace.toUniformSpace",
    "DivisionSemiring.toGroupWithZero",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Real.semiring",
    "instIsTopologicalRingReal",
    "ne_of_gt",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Field.toSemifield",
    "Continuous.div_const",
    "Semifield.toDivisionSemiring",
    "Real.normedCommRing",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "DivInvMonoid.toDiv",
    "Semiring.toNonUnitalSemiring",
    "Zero.toOfNat0",
    "PosMulStrictMono.toPosMulReflectLE",
    "Real.pseudoMetricSpace",
    "div_pos",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "OfNat.ofNat",
    "UniformSpace.toTopologicalSpace",
    "Real.instField",
    "IsStrictOrderedRing.toPosMulStrictMono",
    "Real.instPreorder",
    "Real.linearOrder",
    "MulZeroClass.toZero",
    "PosMulReflectLE.toPosMulReflectLT",
    "Real.instIsStrictOrderedRing"],
   "tactic":
   "exact Continuous.log (hf_cont.div_const _) fun x => ne_of_gt (div_pos (hf_pos x) (hf_pos 0))",
   "proofState": 26,
   "pos": {"line": 98, "column": 10},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1\n⊢ Continuous g",
   "endPos": {"line": 98, "column": 110}},
  {"usedConstants":
   ["Real",
    "HMul.hMul",
    "Real.instOne",
    "Real.instMul",
    "Exists.intro",
    "One.toOfNat1",
    "OfNat.ofNat",
    "Eq",
    "instHMul"],
   "tactic": "use g 1",
   "proofState": 27,
   "pos": {"line": 99, "column": 8},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1\nhg_cont : Continuous g\n⊢ ∃ c, ∀ (x : ℝ), g x = c * x",
   "endPos": {"line": 99, "column": 15}},
  {"usedConstants": ["Real"],
   "tactic": "intros x",
   "proofState": 28,
   "pos": {"line": 100, "column": 8},
   "goals":
   "case h\nf : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := ⋯\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1\nhg_cont : Continuous g\n⊢ ∀ (x : ℝ), g x = g 1 * x",
   "endPos": {"line": 100, "column": 16}},
  {"usedConstants":
   ["Real",
    "HMul.hMul",
    "Real.instOne",
    "Real.instMul",
    "Decidable.byContradiction",
    "One.toOfNat1",
    "OfNat.ofNat",
    "Real.decidableEq",
    "Eq",
    "Not",
    "instHMul"],
   "tactic": "by_contra hg_nonlinear",
   "proofState": 29,
   "pos": {"line": 101, "column": 8},
   "goals":
   "case h\nf : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1\nhg_cont : Continuous g\nx : ℝ\n⊢ g x = g 1 * x",
   "endPos": {"line": 101, "column": 30}},
  {"usedConstants":
   ["Filter.instMembership",
    "Iff.mpr",
    "False",
    "Real",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "Real.lattice",
    "IsTopologicalRing.toIsTopologicalSemiring",
    "Real.instZero",
    "abs",
    "IsTopologicalSemiring.toContinuousMul",
    "Real.instSub",
    "EMetricSpace.metrizableSpace",
    "continuous_const",
    "HSub.hSub",
    "PseudoMetricSpace.toUniformSpace",
    "continuous_id'",
    "Real.instLT",
    "Membership.mem",
    "Exists",
    "nhds",
    "instIsTopologicalRingReal",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "Metric.ball",
    "Real.instAddGroup",
    "HasSubset.Subset",
    "Ne",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Real.instOne",
    "Continuous.mul",
    "IsClosed",
    "GT.gt",
    "And",
    "Real.metricSpace",
    "instHSub",
    "Set.instHasCompl",
    "Real.normedCommRing",
    "Metric.mem_nhds_iff",
    "isClosed_eq",
    "Real.instMul",
    "IsOpen.mem_nhds",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "LT.lt",
    "Iff.mp",
    "One.toOfNat1",
    "Zero.toOfNat0",
    "Real.pseudoMetricSpace",
    "IsOpen",
    "TopologicalSpace.t2Space_of_metrizableSpace",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "MetricSpace.toEMetricSpace",
    "OfNat.ofNat",
    "UniformSpace.toTopologicalSpace",
    "Eq",
    "Filter",
    "isOpen_compl_iff",
    "Set.instHasSubset",
    "HasCompl.compl",
    "instHMul",
    "Set"],
   "tactic":
   "obtain ⟨ε, hε⟩ : ∃ ε > 0, ∀ y, abs (y - x) < ε → g y ≠ g 1 * y := by\n  exact\n    Metric.mem_nhds_iff.mp\n      (IsOpen.mem_nhds (isOpen_compl_iff.mpr <| isClosed_eq hg_cont <| continuous_const.mul continuous_id')\n        hg_nonlinear);",
   "proofState": 30,
   "pos": {"line": 103, "column": 8},
   "goals":
   "case h\nf : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1\nhg_cont : Continuous g\nx : ℝ\nhg_nonlinear : ¬g x = g 1 * x\n⊢ False",
   "endPos": {"line": 104, "column": 159}},
  {"usedConstants":
   ["Filter.instMembership",
    "Iff.mpr",
    "False",
    "Real",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "IsTopologicalRing.toIsTopologicalSemiring",
    "Real.instZero",
    "IsTopologicalSemiring.toContinuousMul",
    "EMetricSpace.metrizableSpace",
    "continuous_const",
    "PseudoMetricSpace.toUniformSpace",
    "continuous_id'",
    "Real.instLT",
    "Membership.mem",
    "Exists",
    "nhds",
    "instIsTopologicalRingReal",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "Metric.ball",
    "HasSubset.Subset",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Real.instOne",
    "Continuous.mul",
    "IsClosed",
    "GT.gt",
    "And",
    "Real.metricSpace",
    "Set.instHasCompl",
    "Real.normedCommRing",
    "Metric.mem_nhds_iff",
    "isClosed_eq",
    "Real.instMul",
    "IsOpen.mem_nhds",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "Iff.mp",
    "One.toOfNat1",
    "Zero.toOfNat0",
    "Real.pseudoMetricSpace",
    "IsOpen",
    "TopologicalSpace.t2Space_of_metrizableSpace",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "MetricSpace.toEMetricSpace",
    "OfNat.ofNat",
    "UniformSpace.toTopologicalSpace",
    "Eq",
    "Filter",
    "isOpen_compl_iff",
    "Set.instHasSubset",
    "HasCompl.compl",
    "instHMul",
    "Set"],
   "tactic":
   "exact\n  Metric.mem_nhds_iff.mp\n    (IsOpen.mem_nhds (isOpen_compl_iff.mpr <| isClosed_eq hg_cont <| continuous_const.mul continuous_id') hg_nonlinear)",
   "proofState": 31,
   "pos": {"line": 104, "column": 10},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1\nhg_cont : Continuous g\nx : ℝ\nhg_nonlinear : ¬g x = g 1 * x\n⊢ ∃ ε > 0, ∀ (y : ℝ), |y - x| < ε → g y ≠ g 1 * y",
   "endPos": {"line": 104, "column": 158}},
  {"usedConstants":
   ["Real",
    "Preorder.toLT",
    "Real.instArchimedean",
    "DivisionRing.toRatCast",
    "Real.instSub",
    "lt_of_not_ge",
    "Rat",
    "PartialOrder.toPreorder",
    "HSub.hSub",
    "Real.instLT",
    "Preorder.toLE",
    "Exists",
    "Field.toDivisionRing",
    "SemilatticeInf.toPartialOrder",
    "DistribLattice.toLattice",
    "Rat.cast",
    "LE.le",
    "exists_rat_btwn",
    "And",
    "instHSub",
    "LT.lt",
    "LinearOrder.toPartialOrder",
    "Real.instField",
    "instDistribLatticeOfLinearOrder",
    "Real.linearOrder",
    "Lattice.toSemilatticeInf",
    "Real.instIsStrictOrderedRing"],
   "tactic":
   "rcases exists_rat_btwn (show x - ε < x by linarith) with ⟨q, hq₁, hq₂⟩",
   "proofState": 32,
   "pos": {"line": 105, "column": 8},
   "goals":
   "case h\nf : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1\nhg_cont : Continuous g\nx : ℝ\nhg_nonlinear : ¬g x = g 1 * x\nε : ℝ\nhε : ε > 0 ∧ ∀ (y : ℝ), |y - x| < ε → g y ≠ g 1 * y\n⊢ False",
   "endPos": {"line": 105, "column": 82}},
  {"usedConstants":
   ["Real",
    "Real.instSub",
    "lt_of_not_ge",
    "PartialOrder.toPreorder",
    "HSub.hSub",
    "Preorder.toLE",
    "LE.le",
    "instHSub",
    "LinearOrder.toPartialOrder",
    "Real.linearOrder"],
   "tactic": "linarith",
   "proofState": 33,
   "pos": {"line": 105, "column": 51},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1\nhg_cont : Continuous g\nx : ℝ\nhg_nonlinear : ¬g x = g 1 * x\nε : ℝ\nhε : ε > 0 ∧ ∀ (y : ℝ), |y - x| < ε → g y ≠ g 1 * y\n⊢ x - ε < x",
   "endPos": {"line": 105, "column": 59}},
  {"usedConstants":
   ["Iff.mpr",
    "AddGroup.toSubtractionMonoid",
    "Real.instIsOrderedRing",
    "Not.intro",
    "NegZeroClass.toNeg",
    "NonAssocSemiring.toAddCommMonoidWithOne",
    "instNeZeroNatHAdd_1",
    "Real.partialOrder",
    "Real",
    "Mathlib.Meta.NormNum.instAddMonoidWithOne",
    "Preorder.toLT",
    "HMul.hMul",
    "Real.lattice",
    "Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt",
    "Nat.rawCast",
    "DivisionRing.toRatCast",
    "AddMonoid.toAddSemigroup",
    "Ring.toNonAssocRing",
    "Mathlib.Tactic.Ring.mul_zero",
    "Mathlib.Tactic.Ring.mul_pf_left",
    "Real.instZero",
    "Real.instAddMonoid",
    "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
    "Real.instRCLike",
    "AddGroupWithOne.toAddGroup",
    "Mathlib.Tactic.Ring.add_pf_add_gt",
    "abs",
    "congrArg",
    "CommSemiring.toSemiring",
    "Mathlib.Tactic.Ring.add_overlap_pf_zero",
    "Mathlib.Tactic.Ring.neg_congr",
    "Mathlib.Tactic.Ring.neg_zero",
    "Real.instSub",
    "Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
    "Mathlib.Tactic.Ring.mul_pf_right",
    "covariant_swap_add_of_covariant_add",
    "lt_of_not_ge",
    "Real.instRatCast",
    "Int.rawCast",
    "PartialOrder.toPreorder",
    "Mathlib.Tactic.Ring.one_mul",
    "Nat.instAtLeastTwoHAddOfNat",
    "AddGroupWithOne.toAddMonoidWithOne",
    "HSub.hSub",
    "Mathlib.Tactic.Ring.zero_mul",
    "Mathlib.Meta.NormNum.IsNat.of_raw",
    "Real.instLT",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Preorder.toLE",
    "Mathlib.Tactic.Linarith.mul_neg",
    "Mathlib.Tactic.Ring.instCommSemiringNat",
    "Field.toDivisionRing",
    "SemilatticeInf.toPartialOrder",
    "Monoid.toNatPow",
    "Mathlib.Tactic.Ring.cast_zero",
    "Real.semiring",
    "Mathlib.Tactic.Ring.neg_mul",
    "Eq.mp",
    "DistribLattice.toLattice",
    "neg_eq_zero",
    "Mathlib.Tactic.Ring.sub_pf",
    "sub_eq_zero_of_eq",
    "Mathlib.Tactic.Ring.neg_add",
    "Distrib.toAdd",
    "Mathlib.Tactic.Ring.add_pf_add_overlap",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "Rat.cast",
    "AddMonoidWithOne.toNatCast",
    "Int.ofNat",
    "Real.instAddGroup",
    "Ne",
    "Real.instRing",
    "SubtractionMonoid.toSubNegZeroMonoid",
    "instOfNatNat",
    "Int",
    "AddCommMonoidWithOne.toAddMonoidWithOne",
    "Mathlib.Tactic.Ring.sub_congr",
    "Mathlib.Meta.NormNum.isNat_ofNat",
    "Mathlib.Meta.NormNum.isInt_mul",
    "LE.le",
    "Real.commRing",
    "SubNegZeroMonoid.toNegZeroClass",
    "Mathlib.Tactic.Ring.of_eq",
    "Real.instAddCommGroup",
    "Mathlib.Tactic.Ring.add_pf_zero_add",
    "SubtractionCommMonoid.toSubtractionMonoid",
    "Real.instAddCommSemigroup",
    "NonAssocRing.toNonUnitalNonAssocRing",
    "Mathlib.Tactic.Ring.mul_congr",
    "Real.instOne",
    "SubNegMonoid.toSub",
    "Mathlib.Tactic.Ring.add_mul",
    "GT.gt",
    "instHAdd",
    "AddSemigroup.toAdd",
    "And",
    "Mathlib.Tactic.Linarith.sub_neg_of_lt",
    "Mathlib.Tactic.Linarith.add_neg",
    "Mathlib.Tactic.Ring.add_pf_add_zero",
    "instHSub",
    "Mathlib.Meta.NormNum.instAtLeastTwo",
    "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
    "AddGroup.toSubNegMonoid",
    "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
    "HPow.hPow",
    "And.right",
    "Distrib.toMul",
    "HAdd.hAdd",
    "Nat.instNeZeroSucc",
    "Mathlib.Meta.NormNum.IsInt.to_isNat",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Mathlib.Tactic.Ring.add_overlap_pf",
    "Nat",
    "Real.instMul",
    "Mathlib.Tactic.Ring.mul_one",
    "And.intro",
    "LT.lt",
    "abs_lt",
    "Mathlib.Tactic.Ring.add_pf_add_lt",
    "Bool",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "instAddNat",
    "Zero.toOfNat0",
    "Mathlib.Meta.NormNum.isInt_add",
    "Eq.refl",
    "Mathlib.Meta.NormNum.IsInt.of_raw",
    "Mathlib.Meta.NormNum.isNat_lt_true",
    "instHPow",
    "Nat.cast_zero",
    "Mathlib.Tactic.Ring.cast_pos",
    "CommRing.toRing",
    "Real.instIsOrderedAddMonoid",
    "Mathlib.Tactic.Ring.atom_pf",
    "AddCommGroup.toDivisionAddCommMonoid",
    "OfNat.ofNat",
    "Bool.false",
    "LinearOrder.toPartialOrder",
    "NegZeroClass.toZero",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "RCLike.charZero_rclike",
    "Mathlib.Tactic.Ring.neg_one_mul",
    "Ring.toAddGroupWithOne",
    "instOfNatAtLeastTwo",
    "Mathlib.Tactic.Linarith.lt_irrefl",
    "instDistribLatticeOfLinearOrder",
    "Neg.neg",
    "Real.instPreorder",
    "MonoidWithZero.toMonoid",
    "Mathlib.Tactic.Ring.mul_add",
    "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
    "Real.linearOrder",
    "Int.negOfNat",
    "Mathlib.Tactic.Linarith.lt_of_lt_of_eq",
    "MulZeroClass.toZero",
    "Lattice.toSemilatticeInf",
    "Mathlib.Tactic.Ring.add_congr",
    "Real.instCommSemiring",
    "Mathlib.Meta.NormNum.IsNat.to_isInt",
    "IsOrderedAddMonoid.toAddLeftMono",
    "Semiring.toMonoidWithZero",
    "instHMul",
    "Real.instNatCast",
    "Real.instIsStrictOrderedRing"],
   "tactic":
   "exact hε.2 q (abs_lt.2 ⟨by linarith, by linarith⟩) (by linarith [hg_linear q])",
   "proofState": 34,
   "pos": {"line": 105, "column": 85},
   "goals":
   "case h\nf : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1\nhg_cont : Continuous g\nx : ℝ\nhg_nonlinear : ¬g x = g 1 * x\nε : ℝ\nhε : ε > 0 ∧ ∀ (y : ℝ), |y - x| < ε → g y ≠ g 1 * y\nq : ℚ\nhq₁ : x - ε < ↑q\nhq₂ : ↑q < x\n⊢ False",
   "endPos": {"line": 105, "column": 171}},
  {"usedConstants":
   ["AddGroup.toSubtractionMonoid",
    "NegZeroClass.toNeg",
    "Real",
    "Real.instSub",
    "lt_of_not_ge",
    "Real.instRatCast",
    "PartialOrder.toPreorder",
    "HSub.hSub",
    "Preorder.toLE",
    "Rat.cast",
    "Real.instAddGroup",
    "SubtractionMonoid.toSubNegZeroMonoid",
    "LE.le",
    "SubNegZeroMonoid.toNegZeroClass",
    "instHSub",
    "LinearOrder.toPartialOrder",
    "Neg.neg",
    "Real.linearOrder"],
   "tactic": "linarith",
   "proofState": 35,
   "pos": {"line": 105, "column": 114},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1\nhg_cont : Continuous g\nx : ℝ\nhg_nonlinear : ¬g x = g 1 * x\nε : ℝ\nhε : ε > 0 ∧ ∀ (y : ℝ), |y - x| < ε → g y ≠ g 1 * y\nq : ℚ\nhq₁ : x - ε < ↑q\nhq₂ : ↑q < x\n⊢ -ε < ↑q - x",
   "endPos": {"line": 105, "column": 122}},
  {"usedConstants":
   ["Real",
    "Real.instSub",
    "lt_of_not_ge",
    "Real.instRatCast",
    "PartialOrder.toPreorder",
    "HSub.hSub",
    "Preorder.toLE",
    "Rat.cast",
    "LE.le",
    "instHSub",
    "LinearOrder.toPartialOrder",
    "Real.linearOrder"],
   "tactic": "linarith",
   "proofState": 36,
   "pos": {"line": 105, "column": 127},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1\nhg_cont : Continuous g\nx : ℝ\nhg_nonlinear : ¬g x = g 1 * x\nε : ℝ\nhε : ε > 0 ∧ ∀ (y : ℝ), |y - x| < ε → g y ≠ g 1 * y\nq : ℚ\nhq₁ : x - ε < ↑q\nhq₂ : ↑q < x\n⊢ ↑q - x < ε",
   "endPos": {"line": 105, "column": 135}},
  {"usedConstants":
   ["Not.intro",
    "Real",
    "Preorder.toLT",
    "HMul.hMul",
    "Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt",
    "Real.instRatCast",
    "PartialOrder.toPreorder",
    "SemilatticeInf.toPartialOrder",
    "DistribLattice.toLattice",
    "Rat.cast",
    "Real.instOne",
    "Real.instMul",
    "LT.lt",
    "One.toOfNat1",
    "OfNat.ofNat",
    "instDistribLatticeOfLinearOrder",
    "Real.linearOrder",
    "Lattice.toSemilatticeInf",
    "instHMul"],
   "tactic": "linarith [hg_linear q]",
   "proofState": 37,
   "pos": {"line": 105, "column": 145},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_linear : ∀ (q : ℚ), g ↑q = ↑q * g 1\nhg_cont : Continuous g\nx : ℝ\nhg_nonlinear : ¬g x = g 1 * x\nε : ℝ\nhε : ε > 0 ∧ ∀ (y : ℝ), |y - x| < ε → g y ≠ g 1 * y\nq : ℚ\nhq₁ : x - ε < ↑q\nhq₂ : ↑q < x\n⊢ g ↑q = g 1 * ↑q",
   "endPos": {"line": 105, "column": 169}},
  {"usedConstants":
   ["Eq.mpr",
    "GroupWithZero.toMonoidWithZero",
    "Exists.choose_spec",
    "Real.partialOrder",
    "Real",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "GroupWithZero.toDivInvMonoid",
    "MulZeroClass.toMul",
    "Real.instZero",
    "congrArg",
    "DivisionSemiring.toGroupWithZero",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Real.semiring",
    "ne_of_gt",
    "id",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "Real.exp",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Real.exp_log",
    "Real.log",
    "Field.toSemifield",
    "mul_div_cancel₀",
    "Semifield.toDivisionSemiring",
    "MonoidWithZero.toMulZeroOneClass",
    "Real.normedCommRing",
    "Real.instMul",
    "Semifield.toCommGroupWithZero",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "Exists.intro",
    "DivInvMonoid.toDiv",
    "Zero.toOfNat0",
    "Eq.refl",
    "PosMulStrictMono.toPosMulReflectLE",
    "Exists.choose",
    "div_pos",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "MulZeroOneClass.toMulZeroClass",
    "CommGroupWithZero.toGroupWithZero",
    "OfNat.ofNat",
    "Eq.symm",
    "Real.instField",
    "Eq",
    "IsStrictOrderedRing.toPosMulStrictMono",
    "Real.instPreorder",
    "Real.linearOrder",
    "MulZeroClass.toZero",
    "PosMulReflectLE.toPosMulReflectLT",
    "instHMul",
    "Real.instIsStrictOrderedRing"],
   "tactic":
   "exact\n  ⟨hg_linear.choose, fun x => by\n    rw [← hg_linear.choose_spec x, Real.exp_log (div_pos (hf_pos x) (hf_pos 0)),\n      mul_div_cancel₀ _ (ne_of_gt (hf_pos 0))]⟩",
   "proofState": 38,
   "pos": {"line": 106, "column": 6},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_linear : ∃ c, ∀ (x : ℝ), g x = c * x\n⊢ ∃ c, ∀ (x : ℝ), f x = f 0 * rexp (c * x)",
   "endPos": {"line": 106, "column": 175}},
  {"usedConstants":
   ["Eq.mpr",
    "GroupWithZero.toMonoidWithZero",
    "Exists.choose_spec",
    "Real.partialOrder",
    "Real",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "GroupWithZero.toDivInvMonoid",
    "MulZeroClass.toMul",
    "Real.instZero",
    "congrArg",
    "DivisionSemiring.toGroupWithZero",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Real.semiring",
    "ne_of_gt",
    "id",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "Real.exp",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Real.exp_log",
    "Real.log",
    "Field.toSemifield",
    "mul_div_cancel₀",
    "Semifield.toDivisionSemiring",
    "MonoidWithZero.toMulZeroOneClass",
    "Real.normedCommRing",
    "Real.instMul",
    "Semifield.toCommGroupWithZero",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "DivInvMonoid.toDiv",
    "Zero.toOfNat0",
    "Eq.refl",
    "PosMulStrictMono.toPosMulReflectLE",
    "Exists.choose",
    "div_pos",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "MulZeroOneClass.toMulZeroClass",
    "CommGroupWithZero.toGroupWithZero",
    "OfNat.ofNat",
    "Eq.symm",
    "Real.instField",
    "Eq",
    "IsStrictOrderedRing.toPosMulStrictMono",
    "Real.instPreorder",
    "Real.linearOrder",
    "MulZeroClass.toZero",
    "PosMulReflectLE.toPosMulReflectLT",
    "instHMul",
    "Real.instIsStrictOrderedRing"],
   "tactic":
   "rw [← hg_linear.choose_spec x, Real.exp_log (div_pos (hf_pos x) (hf_pos 0)), mul_div_cancel₀ _ (ne_of_gt (hf_pos 0))]",
   "proofState": 39,
   "pos": {"line": 106, "column": 44},
   "goals":
   "f : ℝ → ℝ\nhf : ExponentialFunctionalEq f\nhf_pos : ∀ (x : ℝ), 0 < f x\nhf_cont : Continuous f\ng : ℝ → ℝ := fun x => log (f x / f 0)\nhg_add : ∀ (a b : ℝ), g a + g b = g (a + b)\nhg_linear : ∃ c, ∀ (x : ℝ), g x = c * x\nx : ℝ\n⊢ f x = f 0 * rexp (hg_linear.choose * x)",
   "endPos": {"line": 106, "column": 173}},
  {"usedConstants":
   ["Real.partialOrder",
    "Real",
    "HMul.hMul",
    "Finset.univ",
    "Finset",
    "Membership.mem",
    "Finset.sum_pos",
    "Finset.univ_nonempty",
    "Finset.instMembership",
    "Real.exp",
    "Fin.fintype",
    "instNonemptyOfInhabited",
    "Real.instMul",
    "Real.instNeg",
    "Fin.instInhabited",
    "Real.instAddCommMonoid",
    "Fin",
    "EnergyLevels.ε",
    "Neg.neg",
    "Real.exp_pos",
    "instHMul",
    "Real.instIsOrderedCancelAddMonoid"],
   "tactic":
   "exact Finset.sum_pos (fun i _ => Real.exp_pos _) Finset.univ_nonempty",
   "proofState": 40,
   "pos": {"line": 111, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nβ : ℝ\nhβ : 0 ≤ β\n⊢ 0 < partitionFunction levels β",
   "endPos": {"line": 111, "column": 73}},
  {"usedConstants":
   ["Real.partialOrder",
    "Real",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "Finset.univ",
    "MulZeroClass.toMul",
    "Finset",
    "DivisionSemiring.toGroupWithZero",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Membership.mem",
    "Real.semiring",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "Finset.sum_nonneg",
    "Finset.instMembership",
    "Real.exp",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Field.toSemifield",
    "Fin.fintype",
    "Semifield.toDivisionSemiring",
    "Real.normedCommRing",
    "Real.instMul",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "Real.instNeg",
    "Real.instAddCommMonoid",
    "Real.exp_nonneg",
    "PosMulStrictMono.toPosMulReflectLE",
    "div_nonneg",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "Real.instIsOrderedAddMonoid",
    "Fin",
    "Real.instField",
    "EnergyLevels.ε",
    "partitionFunction",
    "IsStrictOrderedRing.toPosMulStrictMono",
    "Neg.neg",
    "Real.linearOrder",
    "MulZeroClass.toZero",
    "IsOrderedAddMonoid.toAddLeftMono",
    "PosMulReflectLE.toPosMulReflectLT",
    "instHMul",
    "Real.instIsStrictOrderedRing"],
   "tactic":
   "exact div_nonneg (Real.exp_nonneg _) (Finset.sum_nonneg fun _ _ => Real.exp_nonneg _)",
   "proofState": 41,
   "pos": {"line": 116, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nβ : ℝ\nhβ : 0 ≤ β\ni : Fin w\n⊢ 0 ≤ boltzmannProb levels β i",
   "endPos": {"line": 116, "column": 91}},
  {"usedConstants":
   ["Real",
    "instHDiv",
    "HMul.hMul",
    "Finset.univ",
    "Real.instDivInvMonoid",
    "HDiv.hDiv",
    "Real.exp",
    "Fin.fintype",
    "Real.instMul",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "Real.instAddCommMonoid",
    "Eq.refl",
    "Fin",
    "Eq",
    "EnergyLevels.ε",
    "partitionFunction",
    "Finset.sum",
    "Neg.neg",
    "boltzmannProb",
    "instHMul"],
   "tactic":
   "have h_sum_def : ∑ i, boltzmannProb levels β i = ∑ i, (Real.exp (-β * levels.ε i) / partitionFunction levels β) := by\n  rfl;",
   "proofState": 42,
   "pos": {"line": 122, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nβ : ℝ\nhβ : 0 ≤ β\n⊢ ∑ i, boltzmannProb levels β i = 1",
   "endPos": {"line": 123, "column": 8}},
  {"usedConstants":
   ["Real",
    "Finset.univ",
    "Fin.fintype",
    "Real.instAddCommMonoid",
    "Eq.refl",
    "Fin",
    "Finset.sum",
    "boltzmannProb"],
   "tactic": "rfl",
   "proofState": 43,
   "pos": {"line": 123, "column": 4},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nβ : ℝ\nhβ : 0 ≤ β\n⊢ ∑ i, boltzmannProb levels β i = ∑ i, rexp (-β * levels.ε i) / partitionFunction levels β",
   "endPos": {"line": 123, "column": 7}},
  {"usedConstants":
   ["Eq.mpr",
    "Real",
    "instHDiv",
    "HMul.hMul",
    "GroupWithZero.toDivInvMonoid",
    "Finset.univ",
    "congrArg",
    "Real.instDivInvMonoid",
    "DivisionSemiring.toGroupWithZero",
    "id",
    "HDiv.hDiv",
    "Real.exp",
    "Field.toSemifield",
    "Fin.fintype",
    "Real.instOne",
    "Finset.sum_div",
    "NonUnitalNonAssocSemiring.toAddCommMonoid",
    "Semifield.toDivisionSemiring",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Real.instMul",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "DivisionSemiring.toSemiring",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "OfNat.ofNat",
    "Eq.symm",
    "Fin",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "EnergyLevels.ε",
    "partitionFunction",
    "Finset.sum",
    "Neg.neg",
    "boltzmannProb",
    "instHMul"],
   "tactic": "rw [h_sum_def, ← Finset.sum_div]",
   "proofState": 44,
   "pos": {"line": 124, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nβ : ℝ\nhβ : 0 ≤ β\nh_sum_def : ∑ i, boltzmannProb levels β i = ∑ i, rexp (-β * levels.ε i) / partitionFunction levels β\n⊢ ∑ i, boltzmannProb levels β i = 1",
   "endPos": {"line": 124, "column": 36}},
  {"usedConstants":
   ["GroupWithZero.toMonoidWithZero",
    "Real",
    "HMul.hMul",
    "Finset.univ",
    "DivisionSemiring.toGroupWithZero",
    "ne_of_gt",
    "Real.exp",
    "Field.toSemifield",
    "Fin.fintype",
    "partitionFunction_pos",
    "NonUnitalNonAssocSemiring.toAddCommMonoid",
    "Semifield.toDivisionSemiring",
    "MonoidWithZero.toMulZeroOneClass",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Real.instMul",
    "Real.instNeg",
    "DivisionSemiring.toSemiring",
    "Zero.toOfNat0",
    "MulZeroOneClass.toMulZeroClass",
    "OfNat.ofNat",
    "Fin",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "EnergyLevels.ε",
    "Finset.sum",
    "Neg.neg",
    "Real.instPreorder",
    "div_self",
    "MulZeroClass.toZero",
    "instHMul"],
   "tactic": "exact div_self <| ne_of_gt <| partitionFunction_pos levels β hβ",
   "proofState": 45,
   "pos": {"line": 125, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nβ : ℝ\nhβ : 0 ≤ β\nh_sum_def : ∑ i, boltzmannProb levels β i = ∑ i, rexp (-β * levels.ε i) / partitionFunction levels β\n⊢ (∑ i, rexp (-β * levels.ε i)) / partitionFunction levels β = 1",
   "endPos": {"line": 125, "column": 65}},
  {"usedConstants":
   ["Real",
    "Exists",
    "sorryAx",
    "instOfNatNat",
    "Lean.Name.num",
    "Lean.Name.str",
    "Lean.Name.anonymous",
    "Nat",
    "Lean.Name",
    "OfNat.ofNat",
    "Bool.false",
    "Fin",
    "Eq",
    "boltzmannProb"],
   "tactic": "sorry",
   "proofState": 46,
   "pos": {"line": 142, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\np : Fin w → ℝ\nhp_pos : ∀ (i : Fin w), 0 < p i\nhp_normalized : ∑ i, p i = 1\nhp_functional : ∀ (a b : Fin w) (hab : ↑a + ↑b < w), p a * p b = p ⟨0, ⋯⟩ * p ⟨↑a + ↑b, hab⟩\n⊢ ∃ β, ∀ (i : Fin w), p i = boltzmannProb levels β i",
   "endPos": {"line": 142, "column": 7}},
  {"usedConstants":
   ["Eq.mpr",
    "Real.partialOrder",
    "Real.instLE",
    "Real",
    "of_decide_eq_true",
    "Real.instZero",
    "Real.instRCLike",
    "Real.instZeroLEOneClass",
    "congrArg",
    "AddMonoid.toAddZeroClass",
    "instDecidableEqFin",
    "Nat.instAtLeastTwoHAddOfNat",
    "AddGroupWithOne.toAddMonoidWithOne",
    "AddZeroClass.toAddZero",
    "Fin.val_eq_zero_iff._simp_1",
    "id",
    "Fin.instOfNat",
    "AddMonoidWithOne.toNatCast",
    "Real.instRing",
    "instOfNatNat",
    "Nat.cast_le._simp_1",
    "LE.le",
    "instLENat",
    "Fin.val",
    "Nat.cast",
    "Real.instOne",
    "AddMonoidWithOne.toOne",
    "Bool.true",
    "AddZero.toZero",
    "Nat.instNeZeroSucc",
    "Nat",
    "congr",
    "Bool",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "Zero.toOfNat0",
    "Eq.refl",
    "instDecidableEqNat",
    "Nat.cast_zero",
    "AddMonoidWithOne.toAddMonoid",
    "Nat.cast_ite._simp_1",
    "Real.instIsOrderedAddMonoid",
    "Nat.decidableForallFin",
    "ite_congr",
    "OfNat.ofNat",
    "Eq.symm",
    "Fin",
    "Decidable.decide",
    "Eq",
    "Nat.cast_one",
    "RCLike.charZero_rclike",
    "Ring.toAddGroupWithOne",
    "instOfNatAtLeastTwo",
    "Not",
    "Nat.decLe",
    "Eq.trans",
    "IsOrderedAddMonoid.toAddLeftMono",
    "Real.instNatCast",
    "forall_congr",
    "ite"],
   "tactic": "norm_cast",
   "proofState": 47,
   "pos": {"line": 147, "column": 4},
   "goals":
   "⊢ ∀ (i : Fin 3), 0 ≤ if ↑i = 0 then 0 else if ↑i = 1 then 1 else 4",
   "endPos": {"line": 147, "column": 13}},
  {"usedConstants": ["badLevels._proof_1"],
   "tactic":
   "grind\n  /-\n  Definition of the counterexample probability distribution and proof that it is positive everywhere.\n  -/\n  ",
   "proofState": 48,
   "pos": {"line": 149, "column": 4},
   "goals": "⊢ (if ↑⟨0, ⋯⟩ = 0 then 0 else if ↑⟨0, ⋯⟩ = 1 then 1 else 4) = 0",
   "endPos": {"line": 149, "column": 9}},
  {"usedConstants": ["instOfNatNat", "Nat", "OfNat.ofNat", "Fin"],
   "tactic": "intro i",
   "proofState": 49,
   "pos": {"line": 157, "column": 2},
   "goals": "⊢ ∀ (i : Fin 3), 0 < badP i",
   "endPos": {"line": 157, "column": 9}},
  {"usedConstants":
   ["Fintype.elems",
    "Finset",
    "Membership.mem",
    "instOfNatNat",
    "Finset.instMembership",
    "Fintype.complete",
    "Fin.fintype",
    "Nat",
    "OfNat.ofNat",
    "Fin"],
   "tactic": "fin_cases i",
   "proofState": 50,
   "pos": {"line": 158, "column": 2},
   "goals": "i : Fin 3\n⊢ 0 < badP i",
   "endPos": {"line": 158, "column": 13}},
  {"usedConstants":
   ["Real.instIsOrderedRing",
    "GroupWithZero.toMonoidWithZero",
    "Real.partialOrder",
    "Real",
    "DivInvMonoid.toInv",
    "Preorder.toLT",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "badP._proof_2",
    "Nat.le_refl",
    "MulZeroClass.toMul",
    "Real.instZero",
    "congrArg",
    "Real.instDivInvMonoid",
    "PartialOrder.toPreorder",
    "Real.instLT",
    "DivisionSemiring.toGroupWithZero",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Real.semiring",
    "Fin.mk",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "badP._proof_1",
    "instOfNatNat",
    "ite_cond_eq_true",
    "Nat.le_of_lt",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Fin.val",
    "Field.toSemifield",
    "inv_pos._simp_1",
    "Real.instOne",
    "Inv.inv",
    "Semifield.toDivisionSemiring",
    "MonoidWithZero.toMulZeroOneClass",
    "Real.normedCommRing",
    "Nat.ofNat_pos._simp_1",
    "Nat",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "LT.lt",
    "one_div",
    "True",
    "eq_self",
    "DivInvMonoid.toDiv",
    "badLevels._proof_3",
    "of_eq_true",
    "One.toOfNat1",
    "Zero.toOfNat0",
    "PosMulStrictMono.toPosMulReflectLE",
    "instDecidableEqNat",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "MulZeroOneClass.toMulZeroClass",
    "OfNat.ofNat",
    "Fin",
    "Real.instField",
    "Eq",
    "IsStrictOrderedRing.toPosMulStrictMono",
    "instOfNatAtLeastTwo",
    "Real.instNontrivial",
    "Real.linearOrder",
    "Eq.trans",
    "MulZeroClass.toZero",
    "PosMulReflectLE.toPosMulReflectLT",
    "Real.instNatCast",
    "ite",
    "Real.instIsStrictOrderedRing"],
   "tactic": "simp [badP]",
   "proofState": 51,
   "pos": {"line": 158, "column": 18},
   "goals": "case «0»\n⊢ 0 < badP ((fun i => i) ⟨0, ⋯⟩)",
   "endPos": {"line": 158, "column": 29}},
  {"usedConstants":
   ["Real.instIsOrderedRing",
    "NonAssocSemiring.toAddCommMonoidWithOne",
    "Nat.instMulZeroClass",
    "Real.partialOrder",
    "Real",
    "Preorder.toLT",
    "instHDiv",
    "Nat.instOne",
    "badP._proof_2",
    "Nat.le_refl",
    "Real.instZero",
    "congrArg",
    "div_pos_iff_of_pos_left._simp_1",
    "Real.instDivInvMonoid",
    "PartialOrder.toPreorder",
    "Real.instLT",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "SemilatticeInf.toPartialOrder",
    "DistribLattice.toLattice",
    "Fin.mk",
    "one_ne_zero._simp_1",
    "HDiv.hDiv",
    "AddMonoidWithOne.toNatCast",
    "badP._proof_1",
    "instOfNatNat",
    "AddCommMonoidWithOne.toAddMonoidWithOne",
    "ite_cond_eq_true",
    "Nat.le_of_lt",
    "Fin.val",
    "Field.toSemifield",
    "Real.instOne",
    "Semifield.toDivisionSemiring",
    "Nat.ofNat_pos._simp_1",
    "Nat.instNeZeroSucc",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Nat",
    "LT.lt",
    "True",
    "eq_self",
    "DivInvMonoid.toDiv",
    "DivisionSemiring.toSemiring",
    "badLevels._proof_3",
    "of_eq_true",
    "One.toOfNat1",
    "Zero.toOfNat0",
    "instDecidableEqNat",
    "OfNat.ofNat",
    "ite_cond_eq_false",
    "Fin",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "instOfNatAtLeastTwo",
    "instDistribLatticeOfLinearOrder",
    "Real.instNontrivial",
    "Real.linearOrder",
    "Eq.trans",
    "MulZeroClass.toZero",
    "Lattice.toSemilatticeInf",
    "Real.instNatCast",
    "ite",
    "Real.instIsStrictOrderedRing"],
   "tactic": "simp [badP]",
   "proofState": 52,
   "pos": {"line": 158, "column": 18},
   "goals": "case «1»\n⊢ 0 < badP ((fun i => i) ⟨1, ⋯⟩)",
   "endPos": {"line": 158, "column": 29}},
  {"usedConstants":
   ["Real.instIsOrderedRing",
    "NonAssocSemiring.toAddCommMonoidWithOne",
    "Real.partialOrder",
    "Real",
    "Preorder.toLT",
    "instHDiv",
    "badP._proof_2",
    "Nat.le_refl",
    "Real.instZero",
    "congrArg",
    "div_pos_iff_of_pos_left._simp_1",
    "Real.instDivInvMonoid",
    "PartialOrder.toPreorder",
    "Nat.instAtLeastTwoHAddOfNat",
    "Real.instLT",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Nat.instCharZero",
    "SemilatticeInf.toPartialOrder",
    "OfNat.ofNat_ne_zero._simp_1",
    "DistribLattice.toLattice",
    "Fin.mk",
    "HDiv.hDiv",
    "AddMonoidWithOne.toNatCast",
    "badP._proof_1",
    "instOfNatNat",
    "AddCommMonoidWithOne.toAddMonoidWithOne",
    "Fin.val",
    "Nat.instAddMonoidWithOne",
    "Field.toSemifield",
    "Real.instOne",
    "Semifield.toDivisionSemiring",
    "Nat.ofNat_pos._simp_1",
    "Nat.instNeZeroSucc",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Nat",
    "LT.lt",
    "True",
    "DivInvMonoid.toDiv",
    "DivisionSemiring.toSemiring",
    "badLevels._proof_3",
    "of_eq_true",
    "One.toOfNat1",
    "Zero.toOfNat0",
    "instDecidableEqNat",
    "OfNat.ofNat_ne_one._simp_1",
    "OfNat.ofNat",
    "ite_cond_eq_false",
    "Fin",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "instOfNatAtLeastTwo",
    "instDistribLatticeOfLinearOrder",
    "Real.instNontrivial",
    "Real.linearOrder",
    "Eq.trans",
    "MulZeroClass.toZero",
    "Lattice.toSemilatticeInf",
    "Real.instNatCast",
    "ite",
    "Real.instIsStrictOrderedRing"],
   "tactic": "simp [badP]",
   "proofState": 53,
   "pos": {"line": 158, "column": 18},
   "goals": "case «2»\n⊢ 0 < badP ((fun i => i) ⟨2, ⋯⟩)",
   "endPos": {"line": 158, "column": 29}},
  {"usedConstants":
   ["Eq.mpr",
    "MulOne.toOne",
    "False",
    "Real",
    "DivInvMonoid.toInv",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "Finset.univ",
    "badP._proof_2",
    "Monoid.toMulOneClass",
    "congrArg",
    "Fin.instNonUnitalCommRing",
    "Finset",
    "Real.instDivInvMonoid",
    "Fin.instNeZeroHAddNatOfNat_mathlib_1",
    "AddMonoid.toAddZeroClass",
    "instDecidableEqFin",
    "Nat.instAtLeastTwoHAddOfNat",
    "eq_false_of_decide",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Membership.mem",
    "Nat.instCharZero",
    "AddZeroClass.toAddZero",
    "Fin.val_eq_zero_iff._simp_1",
    "id",
    "Fin.instOfNat",
    "one_ne_zero._simp_1",
    "HDiv.hDiv",
    "Fin.instCommMonoid",
    "Nat.instMod",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "instHMod",
    "badP._proof_1",
    "instOfNatNat",
    "Finset.instMembership",
    "ite_cond_eq_true",
    "Fin.val",
    "Nat.instAddMonoidWithOne",
    "Fin.sum_univ_three",
    "Fin.fintype",
    "Real.instOne",
    "badP",
    "instHAdd",
    "HMod.hMod",
    "MulOneClass.toMulOne",
    "Inv.inv",
    "HAdd.hAdd",
    "CommMonoid.toMonoid",
    "Nat.instNeZeroSucc",
    "Nat",
    "congr",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "one_div",
    "True",
    "eq_self",
    "DivInvMonoid.toDiv",
    "Nat.one_mod",
    "badLevels._proof_3",
    "Bool",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "instAddNat",
    "AddZero.toAdd",
    "Eq.refl",
    "AddCommMonoid.toAddMonoid",
    "instDecidableEqNat",
    "OfNat.ofNat_ne_one._simp_1",
    "Nat.mod_succ",
    "ite_congr",
    "OfNat.ofNat",
    "ite_cond_eq_false",
    "Bool.false",
    "Fin",
    "Nat.succ",
    "Eq",
    "instOfNatAtLeastTwo",
    "Not",
    "Finset.sum_congr",
    "Finset.sum",
    "Eq.trans",
    "MulZeroClass.toZero",
    "Real.instNatCast",
    "ite"],
   "tactic": "simp [badP, Fin.sum_univ_three]",
   "proofState": 54,
   "pos": {"line": 164, "column": 2},
   "goals": "⊢ ∑ i, badP i = 1",
   "endPos": {"line": 164, "column": 33}},
  {"usedConstants":
   ["Real",
    "DivInvMonoid.toInv",
    "instHDiv",
    "Mathlib.Meta.NormNum.IsNat.to_isNNRat",
    "GroupWithZero.toDivisionMonoid",
    "HMul.hMul",
    "Mathlib.Meta.NormNum.isNat_eq_true",
    "DivInvOneMonoid.toInvOneClass",
    "badP._proof_2",
    "Real.instRCLike",
    "Real.instDivInvMonoid",
    "AddMonoid.toAddZeroClass",
    "AddGroupWithOne.toAddMonoidWithOne",
    "DivisionSemiring.toGroupWithZero",
    "DivisionMonoid.toDivInvOneMonoid",
    "AddZeroClass.toAddZero",
    "Real.semiring",
    "Distrib.toAdd",
    "HDiv.hDiv",
    "AddMonoidWithOne.toNatCast",
    "Real.instRing",
    "badP._proof_1",
    "Mathlib.Meta.NormNum.isNat_ofNat",
    "Mathlib.Meta.NormNum.isNNRat_inv_pos",
    "Field.toSemifield",
    "Real.instOne",
    "instHAdd",
    "Mathlib.Meta.NormNum.instAddMonoidWithOne'",
    "Mathlib.Meta.NormNum.instAtLeastTwo",
    "Inv.inv",
    "Semifield.toDivisionSemiring",
    "Distrib.toMul",
    "HAdd.hAdd",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Nat",
    "DivInvMonoid.toDiv",
    "Mathlib.Meta.NormNum.IsNNRat.to_isNat",
    "DivisionSemiring.toSemiring",
    "badLevels._proof_3",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "AddZero.toAdd",
    "Eq.refl",
    "Mathlib.Meta.NormNum.isNNRat_mul",
    "AddCommMonoid.toAddMonoid",
    "InvOneClass.toInv",
    "Nat.mul",
    "OfNat.ofNat",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Nat.cast_one",
    "Mathlib.Meta.NormNum.isNNRat_div",
    "RCLike.charZero_rclike",
    "Ring.toAddGroupWithOne",
    "instOfNatAtLeastTwo",
    "Mathlib.Meta.NormNum.isNNRat_add",
    "instHMul",
    "Real.instNatCast"],
   "tactic":
   "norm_num\n  /-\n  Proof that the counterexample satisfies the functional equation.\n  -/\n  ",
   "proofState": 55,
   "pos": {"line": 165, "column": 2},
   "goals": "⊢ 7⁻¹ + 2 / 7 + 4 / 7 = 1",
   "endPos": {"line": 165, "column": 10}},
  {"usedConstants":
   ["Nat.instCharZero",
    "Nat.instStarOrderedRing",
    "Nat.instStarRing",
    "instOfNatNat",
    "Mathlib.Meta.NormNum.isNat_ofNat",
    "Nat.instAddMonoidWithOne",
    "Nat",
    "Nat.instCommSemiring",
    "Nat.instPartialOrder",
    "StarOrderedRing.toIsOrderedRing",
    "Bool",
    "Nat.instSemiring",
    "Eq.refl",
    "Mathlib.Meta.NormNum.isNat_lt_true",
    "OfNat.ofNat",
    "Bool.false"],
   "tactic": "norm_num",
   "proofState": 56,
   "pos": {"line": 172, "column": 8},
   "goals": "a b : Fin 3\nhab : ↑a + ↑b < 3\n⊢ 0 < 3",
   "endPos": {"line": 172, "column": 16}},
  {"usedConstants":
   ["Real",
    "HMul.hMul",
    "Nat.instCharZero",
    "Fin.mk",
    "id",
    "Nat.instStarOrderedRing",
    "Nat.instStarRing",
    "instOfNatNat",
    "Mathlib.Meta.NormNum.isNat_ofNat",
    "Fin.val",
    "Nat.instAddMonoidWithOne",
    "badP",
    "instHAdd",
    "HAdd.hAdd",
    "Nat",
    "Real.instMul",
    "LT.lt",
    "Nat.instCommSemiring",
    "Nat.instPartialOrder",
    "StarOrderedRing.toIsOrderedRing",
    "Bool",
    "instAddNat",
    "Nat.instSemiring",
    "Eq.refl",
    "Mathlib.Meta.NormNum.isNat_lt_true",
    "instLTNat",
    "OfNat.ofNat",
    "Bool.false",
    "Fin",
    "Eq",
    "instHMul"],
   "tactic": "unfold badP",
   "proofState": 57,
   "pos": {"line": 173, "column": 8},
   "goals":
   "⊢ ∀ (a b : Fin 3) (hab : ↑a + ↑b < 3), badP a * badP b = badP ⟨0, ⋯⟩ * badP ⟨↑a + ↑b, hab⟩",
   "endPos": {"line": 173, "column": 19}},
  {"usedConstants":
   ["Nat.instCanonicallyOrderedAdd",
    "NonAssocSemiring.toAddCommMonoidWithOne",
    "instNeZeroNatHAdd_1",
    "False",
    "Nat.instMulZeroClass",
    "Mathlib.Meta.NormNum.isNat_add",
    "Real",
    "Preorder.toLT",
    "instHDiv",
    "Mathlib.Meta.NormNum.IsNat.to_isNNRat",
    "Nat.instIsOrderedAddMonoid",
    "GroupWithZero.toDivisionMonoid",
    "HMul.hMul",
    "instDecidableTrue",
    "GroupWithZero.toDivInvMonoid",
    "Mathlib.Meta.NormNum.isNat_eq_true",
    "DivInvOneMonoid.toInvOneClass",
    "eq_false",
    "Nat.instOne",
    "AddMonoid.toAddSemigroup",
    "badP._proof_2",
    "and_true",
    "Fin.succ",
    "Real.instRCLike",
    "congrArg",
    "and_self",
    "IsRightCancelAdd.addRightReflectLE_of_addRightReflectLT",
    "Real.instDivInvMonoid",
    "covariant_swap_add_of_covariant_add",
    "AddMonoid.toAddZeroClass",
    "PartialOrder.toPreorder",
    "instDecidableEqFin",
    "Nat.instAtLeastTwoHAddOfNat",
    "Nat.add_eq_zero_iff._simp_1",
    "AddGroupWithOne.toAddMonoidWithOne",
    "Nat.instZeroLEOneClass",
    "AddCancelMonoid.toAddRightCancelMonoid",
    "DivisionSemiring.toGroupWithZero",
    "Preorder.toLE",
    "Nat.instAddMonoid",
    "lt_self_iff_false._simp_1",
    "DivisionMonoid.toDivInvOneMonoid",
    "Nat.instCharZero",
    "Fin.is_lt._simp_1",
    "mul_ite",
    "AddZeroClass.toAddZero",
    "le_mul_iff_one_le_left'._simp_4",
    "Real.semiring",
    "Fin.mk",
    "Fin.val_eq_zero_iff._simp_1",
    "Nat.instAddCancelCommMonoid",
    "Fin.instOfNat",
    "HDiv.hDiv",
    "Nat.instStarOrderedRing",
    "Nat.instMod",
    "instHMod",
    "AddMonoidWithOne.toNatCast",
    "Nat.instStarRing",
    "Real.instRing",
    "badP._proof_1",
    "instOfNatNat",
    "contravariant_lt_of_covariant_le",
    "AddCommMonoidWithOne.toAddMonoidWithOne",
    "Decidable.not_not._simp_1",
    "Mathlib.Meta.NormNum.isNat_ofNat",
    "Mathlib.Meta.NormNum.IsNNRat.to_eq",
    "Mathlib.Meta.NormNum.isNNRat_inv_pos",
    "LE.le",
    "ite_eq_left_iff._simp_1",
    "imp_self._simp_1",
    "IsEmpty",
    "Nat.lt_add_one._simp_1",
    "Fin.val",
    "zero_add",
    "Nat.instAddMonoidWithOne",
    "Field.toSemifield",
    "Real.instOne",
    "AddMonoidWithOne.toOne",
    "zero_ne_one._simp_1",
    "AddZero.toZero",
    "Fin.val_eq_zero",
    "not_lt._simp_1",
    "instHAdd",
    "HMod.hMod",
    "AddSemigroup.toAdd",
    "And",
    "not_false",
    "Mathlib.Meta.NormNum.instAtLeastTwo",
    "Inv.inv",
    "Semifield.toDivisionSemiring",
    "Distrib.toMul",
    "HAdd.hAdd",
    "Mathlib.Meta.NormNum.isNNRat_eq_false",
    "Nat.instNeZeroSucc",
    "Nat.instPreorder",
    "one_le._simp_4",
    "implies_congr",
    "ite_mul",
    "instNonemptyOfInhabited",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Nat",
    "Real.instMul",
    "forall_const._simp_1",
    "congr",
    "LT.lt",
    "Nat.instCommSemiring",
    "True",
    "eq_self",
    "Mathlib.Meta.NormNum.IsNat.to_eq",
    "instDecidableFalse",
    "DivInvMonoid.toDiv",
    "Nat.instPartialOrder",
    "eq_true",
    "Fin.instInhabited",
    "Mathlib.Meta.NormNum.isNat_natMod",
    "DivisionSemiring.toSemiring",
    "StarOrderedRing.toIsOrderedRing",
    "Nat.one_lt_ofNat._simp_1",
    "badLevels._proof_3",
    "Bool",
    "of_eq_true",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "instAddNat",
    "Nat.instAddCommMonoid",
    "isEmpty_Prop._simp_1",
    "AddZero.toAdd",
    "Nat.instSemiring",
    "Zero.toOfNat0",
    "Eq.refl",
    "Mathlib.Meta.NormNum.instAddMonoidWithOneNat",
    "Mathlib.Meta.NormNum.isNNRat_mul",
    "contravariant_swap_add_of_contravariant_add",
    "InvOneClass.toInv",
    "Fin.succ_ne_zero._simp_1",
    "instDecidableEqNat",
    "AddRightCancelMonoid.toAddRightCancelSemigroup",
    "AddCommSemigroup.toAddCommMagma",
    "Mathlib.Meta.NormNum.isNat_lt_true",
    "implies_true",
    "Nat.mul",
    "and_false",
    "AddMonoidWithOne.toAddMonoid",
    "instLTNat",
    "instDecidableAnd",
    "OfNat.ofNat_ne_one._simp_1",
    "add_zero",
    "ite_congr",
    "OfNat.ofNat",
    "Bool.false",
    "Fin",
    "LinearOrder.toPartialOrder",
    "Mathlib.Meta.NormNum.isNat_eq_false",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "badP_functional._simp_1",
    "Nat.cast_one",
    "Mathlib.Meta.NormNum.isNNRat_div",
    "IsEmpty.forall_iff._simp_1",
    "RCLike.charZero_rclike",
    "Ring.toAddGroupWithOne",
    "instOfNatAtLeastTwo",
    "Not",
    "AddCancelCommMonoid.toAddCancelMonoid",
    "Nat.instAddCommSemigroup",
    "Nat.add_eq_right._simp_1",
    "true_and",
    "Eq.trans",
    "MulZeroClass.toZero",
    "AddCommMagma.toAdd",
    "IsOrderedAddMonoid.toAddLeftMono",
    "True.intro",
    "instHMul",
    "Real.instNatCast",
    "forall_congr",
    "ite",
    "AddRightCancelSemigroup.toIsRightCancelAdd",
    "Nat.instLinearOrder",
    "imp_false._simp_1"],
   "tactic": "norm_num [Fin.forall_fin_succ]",
   "proofState": 58,
   "pos": {"line": 173, "column": 21},
   "goals":
   "⊢ ∀ (a b : Fin 3) (hab : ↑a + ↑b < 3),\n    ((if ↑a = 0 then 1 / 7 else if ↑a = 1 then 2 / 7 else 4 / 7) *\n        if ↑b = 0 then 1 / 7 else if ↑b = 1 then 2 / 7 else 4 / 7) =\n      (if ↑⟨0, ⋯⟩ = 0 then 1 / 7 else if ↑⟨0, ⋯⟩ = 1 then 2 / 7 else 4 / 7) *\n        if ↑⟨↑a + ↑b, hab⟩ = 0 then 1 / 7 else if ↑⟨↑a + ↑b, hab⟩ = 1 then 2 / 7 else 4 / 7",
   "endPos": {"line": 173, "column": 53}},
  {"usedConstants":
   ["Real",
    "instHDiv",
    "HMul.hMul",
    "badP._proof_2",
    "Real.instDivInvMonoid",
    "Exists",
    "id",
    "HDiv.hDiv",
    "badP._proof_1",
    "instOfNatNat",
    "Real.exp",
    "Fin.val",
    "Real.instOne",
    "badP",
    "Nat.instNeZeroSucc",
    "Nat",
    "Real.instMul",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "badLevels._proof_3",
    "One.toOfNat1",
    "instDecidableEqNat",
    "badLevels",
    "OfNat.ofNat",
    "Fin",
    "Eq",
    "EnergyLevels.ε",
    "partitionFunction",
    "instOfNatAtLeastTwo",
    "Not",
    "Neg.neg",
    "boltzmannProb",
    "instHMul",
    "Real.instNatCast",
    "ite"],
   "tactic": "unfold boltzmannProb badP badLevels",
   "proofState": 59,
   "pos": {"line": 179, "column": 2},
   "goals": "⊢ ¬∃ β, ∀ (i : Fin 3), badP i = boltzmannProb badLevels β i",
   "endPos": {"line": 179, "column": 37}},
  {"usedConstants":
   ["Eq.mpr",
    "not_exists._simp_1",
    "Nat.instCanonicallyOrderedAdd",
    "NonAssocSemiring.toAddCommMonoidWithOne",
    "Real.instLE",
    "Real",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "Mathlib.Meta.NormNum.IsNat.to_isNNRat",
    "GroupWithZero.toDivisionMonoid",
    "HMul.hMul",
    "GroupWithZero.toDivInvMonoid",
    "DivInvOneMonoid.toInvOneClass",
    "badP._proof_2",
    "EnergyLevels.mk.congr_simp",
    "Real.instZero",
    "Real.instRCLike",
    "congrArg",
    "Real.instDivInvMonoid",
    "AddMonoid.toAddZeroClass",
    "instDecidableEqFin",
    "AddGroupWithOne.toAddMonoidWithOne",
    "badLevels._proof_1",
    "DivisionSemiring.toGroupWithZero",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Nat.instAddMonoid",
    "DivisionMonoid.toDivInvOneMonoid",
    "Exists",
    "mul_ite",
    "Real.semiring",
    "Fin.mk",
    "Fin.val_eq_zero_iff._simp_1",
    "id",
    "Fin.instOfNat",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "AddMonoidWithOne.toNatCast",
    "Real.instRing",
    "badP._proof_1",
    "NonAssocSemiring.toMulZeroOneClass",
    "EnergyLevels.mk",
    "instOfNatNat",
    "AddCommMonoidWithOne.toAddMonoidWithOne",
    "Mathlib.Meta.NormNum.isNat_ofNat",
    "Mathlib.Meta.NormNum.IsNNRat.to_eq",
    "Mathlib.Meta.NormNum.isNNRat_inv_pos",
    "LE.le",
    "Real.exp",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Fin.val",
    "Field.toSemifield",
    "MulZeroClass.mul_zero",
    "MulZeroOneClass.toMulOneClass",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "Real.instOne",
    "AddMonoidWithOne.toOne",
    "funext",
    "badLevels._proof_2",
    "badLevels._proof_4",
    "Mathlib.Meta.NormNum.instAtLeastTwo",
    "Inv.inv",
    "Semifield.toDivisionSemiring",
    "Real.normedCommRing",
    "Distrib.toMul",
    "Nat.instNeZeroSucc",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Nat",
    "Real.instMul",
    "congr",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "Nat.instPartialOrder",
    "DivisionSemiring.toSemiring",
    "badLevels._proof_3",
    "Eq.ndrec",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "NeZero.pos",
    "Zero.toOfNat0",
    "Eq.refl",
    "Classical.not_forall._simp_1",
    "Mathlib.Meta.NormNum.isNNRat_mul",
    "neg_mul",
    "InvOneClass.toInv",
    "instDecidableEqNat",
    "Nat.mul",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "HasDistribNeg.toInvolutiveNeg",
    "mul_one",
    "InvolutiveNeg.toNeg",
    "ite_congr",
    "OfNat.ofNat",
    "Fin",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "EnergyLevels.ε",
    "Nat.cast_one",
    "Mathlib.Meta.NormNum.isNNRat_div",
    "partitionFunction",
    "RCLike.charZero_rclike",
    "Ring.toAddGroupWithOne",
    "instOfNatAtLeastTwo",
    "Not",
    "EnergyLevels",
    "Neg.neg",
    "Eq.trans",
    "MulZeroClass.toZero",
    "instHMul",
    "Real.instNatCast",
    "forall_congr",
    "ite"],
   "tactic": "norm_num",
   "proofState": 60,
   "pos": {"line": 179, "column": 40},
   "goals":
   "⊢ ¬∃ β,\n      ∀ (i : Fin 3),\n        (if ↑i = 0 then 1 / 7 else if ↑i = 1 then 2 / 7 else 4 / 7) =\n          rexp\n              (-β *\n                { ε := fun i => if ↑i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := badLevels._proof_4,\n                      ε_zero := badLevels._proof_1 }.ε\n                  i) /\n            partitionFunction\n              { ε := fun i => if ↑i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := badLevels._proof_4,\n                ε_zero := badLevels._proof_1 }\n              β",
   "endPos": {"line": 179, "column": 48}},
  {"usedConstants":
   ["Nat.instCanonicallyOrderedAdd",
    "NonAssocSemiring.toAddCommMonoidWithOne",
    "Real.instLE",
    "Real",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "GroupWithZero.toDivInvMonoid",
    "Real.instZero",
    "Real.instDivInvMonoid",
    "AddMonoid.toAddZeroClass",
    "Classical.byContradiction",
    "instDecidableEqFin",
    "badLevels._proof_1",
    "DivisionSemiring.toGroupWithZero",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Nat.instAddMonoid",
    "Exists",
    "Fin.mk",
    "Fin.val_eq_zero_iff._simp_1",
    "Fin.instOfNat",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "AddMonoidWithOne.toNatCast",
    "EnergyLevels.mk",
    "instOfNatNat",
    "AddCommMonoidWithOne.toAddMonoidWithOne",
    "LE.le",
    "Real.exp",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Fin.val",
    "Field.toSemifield",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "Real.instOne",
    "AddMonoidWithOne.toOne",
    "funext",
    "badLevels._proof_2",
    "badLevels._proof_4",
    "Mathlib.Meta.NormNum.instAtLeastTwo",
    "Semifield.toDivisionSemiring",
    "Real.normedCommRing",
    "Distrib.toMul",
    "Nat.instNeZeroSucc",
    "Nat",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "Nat.instPartialOrder",
    "DivisionSemiring.toSemiring",
    "badLevels._proof_3",
    "Eq.ndrec",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "NeZero.pos",
    "Zero.toOfNat0",
    "Eq.refl",
    "instDecidableEqNat",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "HasDistribNeg.toInvolutiveNeg",
    "InvolutiveNeg.toNeg",
    "ite_congr",
    "OfNat.ofNat",
    "Fin",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "partitionFunction",
    "instOfNatAtLeastTwo",
    "Not",
    "Neg.neg",
    "MulZeroClass.toZero",
    "instHMul",
    "Real.instNatCast",
    "ite"],
   "tactic": "by_contra! h",
   "proofState": 61,
   "pos": {"line": 180, "column": 2},
   "goals":
   "⊢ ∀ (x : ℝ),\n    ∃ x_1,\n      ¬(if x_1 = 0 then 1 / 7 else if ↑x_1 = 1 then 2 / 7 else 4 / 7) =\n          rexp (if x_1 = 0 then 0 else if ↑x_1 = 1 then -x else -(x * 4)) /\n            partitionFunction { ε := fun i => if i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := ⋯, ε_zero := ⋯ }\n              x",
   "endPos": {"line": 180, "column": 14}},
  {"usedConstants":
   ["Nat.instCanonicallyOrderedAdd",
    "NonAssocSemiring.toAddCommMonoidWithOne",
    "instNeZeroNatHAdd_1",
    "Real.instLE",
    "Real",
    "DivInvMonoid.toInv",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "GroupWithZero.toDivInvMonoid",
    "DivisionCommMonoid.toDivisionMonoid",
    "Fin.succ",
    "Real.instZero",
    "congrArg",
    "Real.instDivInvMonoid",
    "AddMonoid.toAddZeroClass",
    "instDecidableEqFin",
    "badLevels._proof_1",
    "DivisionSemiring.toGroupWithZero",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Nat.instAddMonoid",
    "Exists",
    "Eq.mp",
    "Fin.mk",
    "Fin.val_eq_zero_iff._simp_1",
    "Fin.instOfNat",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "AddMonoidWithOne.toNatCast",
    "EnergyLevels.mk",
    "instOfNatNat",
    "AddCommMonoidWithOne.toAddMonoidWithOne",
    "LE.le",
    "ite_cond_eq_true",
    "Real.exp",
    "DivisionMonoid.toInvolutiveInv",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Fin.val",
    "Field.toSemifield",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "Real.instOne",
    "AddMonoidWithOne.toOne",
    "Bool.true",
    "funext",
    "instHAdd",
    "badLevels._proof_2",
    "And",
    "badLevels._proof_4",
    "Mathlib.Meta.NormNum.instAtLeastTwo",
    "Inv.inv",
    "Semifield.toDivisionSemiring",
    "Real.normedCommRing",
    "Distrib.toMul",
    "HAdd.hAdd",
    "eq_true_of_decide",
    "Nat.instNeZeroSucc",
    "instNonemptyOfInhabited",
    "Nat",
    "forall_const._simp_1",
    "congr",
    "Semifield.toCommGroupWithZero",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "one_div",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "Nat.instPartialOrder",
    "Fin.instInhabited",
    "DivisionSemiring.toSemiring",
    "badLevels._proof_3",
    "Bool",
    "Eq.ndrec",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "instAddNat",
    "NeZero.pos",
    "Zero.toOfNat0",
    "Eq.refl",
    "CommGroupWithZero.toDivisionCommMonoid",
    "Fin.succ_ne_zero._simp_1",
    "instDecidableEqNat",
    "Real.exp_zero",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "HasDistribNeg.toInvolutiveNeg",
    "InvolutiveNeg.toNeg",
    "ite_congr",
    "OfNat.ofNat",
    "ite_cond_eq_false",
    "Fin",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "inv_inj._simp_3",
    "badP_functional._simp_1",
    "partitionFunction",
    "instOfNatAtLeastTwo",
    "Not",
    "Neg.neg",
    "Nat.add_eq_right._simp_1",
    "Eq.trans",
    "MulZeroClass.toZero",
    "instHMul",
    "Real.instNatCast",
    "forall_congr",
    "ite"],
   "tactic": "simp_all +decide [Fin.forall_fin_succ]",
   "proofState": 62,
   "pos": {"line": 181, "column": 2},
   "goals":
   "h :\n  ∃ x,\n    ∀ (x_1 : Fin 3),\n      (if x_1 = 0 then 1 / 7 else if ↑x_1 = 1 then 2 / 7 else 4 / 7) =\n        rexp (if x_1 = 0 then 0 else if ↑x_1 = 1 then -x else -(x * 4)) /\n          partitionFunction { ε := fun i => if i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := ⋯, ε_zero := ⋯ } x\n⊢ False",
   "endPos": {"line": 181, "column": 42}},
  {"usedConstants":
   ["Nat.instCanonicallyOrderedAdd",
    "NonAssocSemiring.toAddCommMonoidWithOne",
    "Real.instPow",
    "Real.instLE",
    "Real.exp_mul",
    "Real",
    "DivInvMonoid.toInv",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "Mathlib.Meta.NormNum.IsNat.to_isNNRat",
    "GroupWithZero.toDivisionMonoid",
    "HMul.hMul",
    "GroupWithZero.toDivInvMonoid",
    "DivInvOneMonoid.toInvOneClass",
    "Real.instZero",
    "Monoid.toMulOneClass",
    "Real.instRCLike",
    "congrArg",
    "Real.instInv",
    "Real.instDivInvMonoid",
    "AddMonoid.toAddZeroClass",
    "instDecidableEqFin",
    "AddGroupWithOne.toAddMonoidWithOne",
    "badLevels._proof_1",
    "DivisionSemiring.toGroupWithZero",
    "Nat.instAddMonoid",
    "DivisionMonoid.toDivInvOneMonoid",
    "Exists",
    "Monoid.toNatPow",
    "Real.semiring",
    "Eq.mp",
    "Fin.mk",
    "Fin.val_eq_zero_iff._simp_1",
    "Fin.instOfNat",
    "MulOne.toMul",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "DivInvMonoid.toMonoid",
    "AddMonoidWithOne.toNatCast",
    "Real.instRing",
    "EnergyLevels.mk",
    "instOfNatNat",
    "AddCommMonoidWithOne.toAddMonoidWithOne",
    "Mathlib.Meta.NormNum.isNat_ofNat",
    "Mathlib.Meta.NormNum.IsNNRat.to_eq",
    "Mathlib.Meta.NormNum.isNNRat_inv_pos",
    "LE.le",
    "Real.exp",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Fin.val",
    "div_eq_mul_inv",
    "Field.toSemifield",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "Real.instOne",
    "Real.instMonoid",
    "funext",
    "badLevels._proof_2",
    "MulOneClass.toMulOne",
    "And",
    "badLevels._proof_4",
    "Mathlib.Meta.NormNum.instAtLeastTwo",
    "Inv.inv",
    "Semifield.toDivisionSemiring",
    "HPow.hPow",
    "Real.normedCommRing",
    "Distrib.toMul",
    "Nat.instNeZeroSucc",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Nat",
    "Real.instMul",
    "congr",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "Nat.instPartialOrder",
    "DivisionSemiring.toSemiring",
    "badLevels._proof_3",
    "Real.rpow_ofNat",
    "Eq.ndrec",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "NeZero.pos",
    "Zero.toOfNat0",
    "Eq.refl",
    "Mathlib.Meta.NormNum.isNNRat_mul",
    "InvOneClass.toInv",
    "instDecidableEqNat",
    "Nat.mul",
    "instHPow",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "HasDistribNeg.toInvolutiveNeg",
    "InvolutiveNeg.toNeg",
    "ite_congr",
    "OfNat.ofNat",
    "Fin",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "Mathlib.Meta.NormNum.isNNRat_div",
    "Real.exp_neg",
    "partitionFunction",
    "RCLike.charZero_rclike",
    "Ring.toAddGroupWithOne",
    "instOfNatAtLeastTwo",
    "Not",
    "Neg.neg",
    "Eq.trans",
    "instHMul",
    "Real.instNatCast",
    "ite"],
   "tactic": "norm_num [div_eq_mul_inv, Real.exp_mul, Real.exp_neg] at *",
   "proofState": 63,
   "pos": {"line": 182, "column": 2},
   "goals":
   "h :\n  ∃ x,\n    7 = partitionFunction { ε := fun i => if i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := ⋯, ε_zero := ⋯ } x ∧\n      2 / 7 =\n          rexp (-x) /\n            partitionFunction { ε := fun i => if i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := ⋯, ε_zero := ⋯ }\n              x ∧\n        4 / 7 =\n          rexp (-(x * 4)) /\n            partitionFunction { ε := fun i => if i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := ⋯, ε_zero := ⋯ }\n              x\n⊢ False",
   "endPos": {"line": 182, "column": 62}},
  {"usedConstants": ["badP_not_boltzmann._proof_5"],
   "tactic":
   "grind\n  /-\n  Disproof of the Boltzmann distribution derivation theorem using the counterexample.\n  -/\n  ",
   "proofState": 64,
   "pos": {"line": 183, "column": 2},
   "goals":
   "h :\n  ∃ x,\n    7 = partitionFunction { ε := fun i => if i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := ⋯, ε_zero := ⋯ } x ∧\n      2 / 7 =\n          (rexp x)⁻¹ *\n            (partitionFunction\n                { ε := fun i => if i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := ⋯, ε_zero := ⋯ } x)⁻¹ ∧\n        4 / 7 =\n          (rexp x ^ 4)⁻¹ *\n            (partitionFunction\n                { ε := fun i => if i = 0 then 0 else if ↑i = 1 then 1 else 4, ε_nonneg := ⋯, ε_zero := ⋯ } x)⁻¹\n⊢ False",
   "endPos": {"line": 183, "column": 7}},
  {"usedConstants":
   ["Nat.instCanonicallyOrderedAdd",
    "Nat.instMulZeroClass",
    "Real",
    "HMul.hMul",
    "Finset.univ",
    "Real.instZero",
    "AddMonoid.toAddZeroClass",
    "Real.instLT",
    "Nat.instAddMonoid",
    "Exists",
    "Fin.mk",
    "instOfNatNat",
    "Fin.val",
    "Fin.fintype",
    "Real.instOne",
    "instHAdd",
    "HAdd.hAdd",
    "Nat",
    "Real.instMul",
    "LT.lt",
    "Nat.instPartialOrder",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "instAddNat",
    "NeZero.pos",
    "Zero.toOfNat0",
    "instLTNat",
    "NeZero",
    "OfNat.ofNat",
    "Fin",
    "Eq",
    "Finset.sum",
    "EnergyLevels",
    "boltzmannProb",
    "MulZeroClass.toZero",
    "instHMul"],
   "tactic": "intro h",
   "proofState": 65,
   "pos": {"line": 195, "column": 2},
   "goals":
   "⊢ ¬∀ {w : ℕ} [inst : NeZero w] (levels : EnergyLevels w) (p : Fin w → ℝ),\n      (∀ (i : Fin w), 0 < p i) →\n        ∑ i, p i = 1 →\n          (∀ (a b : Fin w) (hab : ↑a + ↑b < w), p a * p b = p ⟨0, ⋯⟩ * p ⟨↑a + ↑b, hab⟩) →\n            ∃ β, ∀ (i : Fin w), p i = boltzmannProb levels β i",
   "endPos": {"line": 195, "column": 9}},
  {"usedConstants":
   ["Real",
    "badP_pos",
    "Exists",
    "badP_sum",
    "instOfNatNat",
    "badP",
    "Nat.instNeZeroSucc",
    "Nat",
    "badLevels",
    "OfNat.ofNat",
    "Fin",
    "Eq",
    "badP_functional",
    "boltzmannProb"],
   "tactic": "specialize h badLevels badP badP_pos badP_sum badP_functional",
   "proofState": 66,
   "pos": {"line": 196, "column": 2},
   "goals":
   "h :\n  ∀ {w : ℕ} [inst : NeZero w] (levels : EnergyLevels w) (p : Fin w → ℝ),\n    (∀ (i : Fin w), 0 < p i) →\n      ∑ i, p i = 1 →\n        (∀ (a b : Fin w) (hab : ↑a + ↑b < w), p a * p b = p ⟨0, ⋯⟩ * p ⟨↑a + ↑b, hab⟩) →\n          ∃ β, ∀ (i : Fin w), p i = boltzmannProb levels β i\n⊢ False",
   "endPos": {"line": 196, "column": 63}},
  {"usedConstants": ["badP_not_boltzmann"],
   "tactic": "exact badP_not_boltzmann h",
   "proofState": 67,
   "pos": {"line": 197, "column": 2},
   "goals":
   "h : ∃ β, ∀ (i : Fin 3), badP i = boltzmannProb badLevels β i\n⊢ False",
   "endPos": {"line": 197, "column": 28}},
  {"usedConstants":
   ["Mathlib.Tactic.Push.not_forall_eq",
    "Mathlib.Tactic.Push.not_exists._simp_1",
    "Iff.mpr",
    "Eq.mpr",
    "Nat.instCanonicallyOrderedAdd",
    "Nat.instMulZeroClass",
    "Real",
    "HMul.hMul",
    "Finset.univ",
    "Real.instZero",
    "Iff.of_eq",
    "congrArg",
    "AddMonoid.toAddZeroClass",
    "Real.instLT",
    "Nat.instAddMonoid",
    "Exists",
    "sorryAx",
    "Fin.mk",
    "id",
    "Ne",
    "instOfNatNat",
    "Lean.Name.num",
    "Fin.val",
    "Lean.Name.str",
    "Fin.fintype",
    "Classical.not_imp._simp_2",
    "Lean.Name.anonymous",
    "Real.instOne",
    "funext",
    "instHAdd",
    "And",
    "HAdd.hAdd",
    "binderNameHint",
    "Nat",
    "Real.instMul",
    "exists_prop_congr",
    "LT.lt",
    "propext",
    "Nat.instPartialOrder",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "instAddNat",
    "Lean.Name",
    "NeZero.pos",
    "Zero.toOfNat0",
    "Eq.refl",
    "instLTNat",
    "NeZero",
    "OfNat.ofNat",
    "Bool.false",
    "Fin",
    "Eq",
    "Not",
    "Finset.sum",
    "EnergyLevels",
    "boltzmannProb",
    "Eq.trans",
    "MulZeroClass.toZero",
    "instHMul",
    "forall_congr"],
   "tactic": "negate_state",
   "proofState": 68,
   "pos": {"line": 214, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\np : Fin w → ℝ\nhp_pos : ∀ (i : Fin w), 0 < p i\nhp_normalized : ∑ i, p i = 1\nhp_functional : ∀ (a b : Fin w) (hab : ↑a + ↑b < w), p a * p b = p ⟨0, ⋯⟩ * p ⟨↑a + ↑b, hab⟩\n⊢ ∃ β, ∀ (i : Fin w), p i = boltzmannProb levels β i",
   "endPos": {"line": 214, "column": 14}},
  {"usedConstants":
   ["Iff.mpr",
    "Nat.instCanonicallyOrderedAdd",
    "Nat.instMulZeroClass",
    "Real",
    "HMul.hMul",
    "Finset.univ",
    "Real.instZero",
    "Iff.of_eq",
    "AddMonoid.toAddZeroClass",
    "Real.instLT",
    "Nat.instAddMonoid",
    "Exists",
    "inferInstance",
    "Fin.mk",
    "Ne",
    "instOfNatNat",
    "Fin.val",
    "Fin.fintype",
    "Real.instOne",
    "instHAdd",
    "And",
    "HAdd.hAdd",
    "Nat.instNeZeroSucc",
    "Nat",
    "Real.instMul",
    "LT.lt",
    "Exists.intro",
    "Nat.instPartialOrder",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "instAddNat",
    "NeZero.pos",
    "Zero.toOfNat0",
    "Eq.refl",
    "instLTNat",
    "NeZero",
    "OfNat.ofNat",
    "Fin",
    "Eq",
    "Finset.sum",
    "EnergyLevels",
    "boltzmannProb",
    "MulZeroClass.toZero",
    "instHMul"],
   "tactic":
   "use 3, by\n  -- Show that 3 is a positive natural number.\n  infer_instance",
   "proofState": 69,
   "pos": {"line": 217, "column": 2},
   "goals":
   "⊢ ∃ w,\n    ∃ (h : NeZero w),\n      ∃ levels p,\n        (∀ (i : Fin w), 0 < p i) ∧\n          ∑ i, p i = 1 ∧\n            (∀ (a b : Fin w) (hab : ↑a + ↑b < w), p a * p b = p ⟨0, ⋯⟩ * p ⟨↑a + ↑b, hab⟩) ∧\n              ∀ (β : ℝ), ∃ i, p i ≠ boltzmannProb levels β i",
   "endPos": {"line": 219, "column": 18}},
  {"usedConstants":
   ["Nat.instMulZeroClass",
    "inferInstance",
    "instOfNatNat",
    "Nat.instNeZeroSucc",
    "Nat",
    "NeZero",
    "OfNat.ofNat",
    "MulZeroClass.toZero"],
   "tactic": "infer_instance",
   "proofState": 70,
   "pos": {"line": 219, "column": 4},
   "goals": "⊢ NeZero 3",
   "endPos": {"line": 219, "column": 18}},
  {"usedConstants":
   ["Iff.mpr",
    "Nat.instCanonicallyOrderedAdd",
    "Nat.instMulZeroClass",
    "Iff.of_eq",
    "AddMonoid.toAddZeroClass",
    "Nat.instAddMonoid",
    "inferInstance",
    "id",
    "instOfNatNat",
    "Nat.instNeZeroSucc",
    "Nat",
    "LT.lt",
    "Nat.instPartialOrder",
    "NeZero.pos",
    "Eq.refl",
    "instLTNat",
    "NeZero",
    "OfNat.ofNat",
    "MulZeroClass.toZero"],
   "tactic": "generalize_proofs at *",
   "proofState": 71,
   "pos": {"line": 220, "column": 2},
   "goals":
   "case h\n⊢ ∃ levels p,\n    (∀ (i : Fin 3), 0 < p i) ∧\n      ∑ i, p i = 1 ∧\n        (∀ (a b : Fin 3) (hab : ↑a + ↑b < 3), p a * p b = p ⟨0, ⋯⟩ * p ⟨↑a + ↑b, hab⟩) ∧\n          ∀ (β : ℝ), ∃ i, p i ≠ boltzmannProb levels β i",
   "endPos": {"line": 220, "column": 24}},
  {"usedConstants":
   ["Nat.instMulZeroClass",
    "instOfNatNat",
    "Nat",
    "NeZero",
    "OfNat.ofNat",
    "MulZeroClass.toZero"],
   "tactic": "generalize_proofs at *",
   "proofState": 72,
   "pos": {"line": 221, "column": 2},
   "goals":
   "case h\npf✝¹ : NeZero 3\npf✝ : 0 < 3\n⊢ ∃ levels p,\n    (∀ (i : Fin 3), 0 < p i) ∧\n      ∑ i, p i = 1 ∧\n        (∀ (a b : Fin 3) (hab : ↑a + ↑b < 3), p a * p b = p ⟨0, pf✝⟩ * p ⟨↑a + ↑b, hab⟩) ∧\n          ∀ (β : ℝ), ∃ i, p i ≠ boltzmannProb levels β i",
   "endPos": {"line": 221, "column": 24}},
  {"usedConstants":
   ["Real",
    "HMul.hMul",
    "Finset.univ",
    "Real.instZero",
    "Real.instLT",
    "Exists",
    "Fin.mk",
    "Ne",
    "instOfNatNat",
    "Fin.val",
    "Fin.fintype",
    "Real.instOne",
    "badP",
    "instHAdd",
    "And",
    "HAdd.hAdd",
    "Nat",
    "Real.instMul",
    "LT.lt",
    "Exists.intro",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "instAddNat",
    "Zero.toOfNat0",
    "instLTNat",
    "badLevels",
    "OfNat.ofNat",
    "Fin",
    "Eq",
    "Finset.sum",
    "EnergyLevels",
    "boltzmannProb",
    "instHMul"],
   "tactic": "use badLevels, badP",
   "proofState": 73,
   "pos": {"line": 223, "column": 2},
   "goals":
   "case h\npf✝¹ : NeZero 3\npf✝ : 0 < 3\n⊢ ∃ levels p,\n    (∀ (i : Fin 3), 0 < p i) ∧\n      ∑ i, p i = 1 ∧\n        (∀ (a b : Fin 3) (hab : ↑a + ↑b < 3), p a * p b = p ⟨0, pf✝⟩ * p ⟨↑a + ↑b, hab⟩) ∧\n          ∀ (β : ℝ), ∃ i, p i ≠ boltzmannProb levels β i",
   "endPos": {"line": 223, "column": 21}},
  {"usedConstants":
   ["Nat.instMulZeroClass",
    "instOfNatNat",
    "Nat",
    "NeZero",
    "OfNat.ofNat",
    "MulZeroClass.toZero"],
   "tactic": "generalize_proofs at *",
   "proofState": 74,
   "pos": {"line": 224, "column": 2},
   "goals":
   "case h\npf✝¹ : NeZero 3\npf✝ : 0 < 3\n⊢ (∀ (i : Fin 3), 0 < badP i) ∧\n    ∑ i, badP i = 1 ∧\n      (∀ (a b : Fin 3) (hab : ↑a + ↑b < 3), badP a * badP b = badP ⟨0, pf✝⟩ * badP ⟨↑a + ↑b, hab⟩) ∧\n        ∀ (β : ℝ), ∃ i, badP i ≠ boltzmannProb badLevels β i",
   "endPos": {"line": 224, "column": 24}},
  {"usedConstants":
   ["Real",
    "HMul.hMul",
    "Finset.univ",
    "Real.instZero",
    "badP_pos",
    "Real.instLT",
    "Exists",
    "Nat.instCharZero",
    "Fin.mk",
    "badP_sum",
    "Nat.instStarOrderedRing",
    "Nat.instStarRing",
    "Ne",
    "instOfNatNat",
    "Mathlib.Meta.NormNum.isNat_ofNat",
    "Fin.val",
    "Nat.instAddMonoidWithOne",
    "Fin.fintype",
    "Real.instOne",
    "badP",
    "instHAdd",
    "And",
    "HAdd.hAdd",
    "Nat",
    "Real.instMul",
    "And.intro",
    "LT.lt",
    "Nat.instCommSemiring",
    "Nat.instPartialOrder",
    "StarOrderedRing.toIsOrderedRing",
    "Bool",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "instAddNat",
    "Nat.instSemiring",
    "Zero.toOfNat0",
    "Eq.refl",
    "Mathlib.Meta.NormNum.isNat_lt_true",
    "instLTNat",
    "badLevels",
    "OfNat.ofNat",
    "Bool.false",
    "Fin",
    "Eq",
    "badP_functional",
    "Finset.sum",
    "boltzmannProb",
    "instHMul"],
   "tactic":
   "apply\n  And.intro (badP_pos)\n    (And.intro (badP_sum) (And.intro (badP_functional) (fun x => by by_contra! h; exact badP_not_boltzmann ⟨x, h⟩)))",
   "proofState": 75,
   "pos": {"line": 226, "column": 2},
   "goals":
   "case h\npf✝¹ : NeZero 3\npf✝ : 0 < 3\n⊢ (∀ (i : Fin 3), 0 < badP i) ∧\n    ∑ i, badP i = 1 ∧\n      (∀ (a b : Fin 3) (hab : ↑a + ↑b < 3), badP a * badP b = badP ⟨0, pf✝⟩ * badP ⟨↑a + ↑b, hab⟩) ∧\n        ∀ (β : ℝ), ∃ i, badP i ≠ boltzmannProb badLevels β i",
   "endPos": {"line": 228, "column": 40}},
  {"usedConstants":
   ["instDecidableNot",
    "Real",
    "Exists",
    "Ne",
    "instOfNatNat",
    "badP",
    "Nat",
    "Decidable.byContradiction",
    "Nat.decidableExistsFin",
    "badLevels",
    "OfNat.ofNat",
    "Real.decidableEq",
    "Fin",
    "Eq",
    "Not",
    "boltzmannProb"],
   "tactic": "by_contra! h",
   "proofState": 76,
   "pos": {"line": 227, "column": 4},
   "goals":
   "pf✝¹ : NeZero 3\npf✝ : 0 < 3\nx : ℝ\n⊢ ∃ i, badP i ≠ boltzmannProb badLevels x i",
   "endPos": {"line": 227, "column": 16}},
  {"usedConstants":
   ["Real",
    "instOfNatNat",
    "badP",
    "Nat.instNeZeroSucc",
    "Nat",
    "Exists.intro",
    "badP_not_boltzmann",
    "badLevels",
    "OfNat.ofNat",
    "Fin",
    "Eq",
    "boltzmannProb"],
   "tactic": "exact badP_not_boltzmann ⟨x, h⟩",
   "proofState": 77,
   "pos": {"line": 228, "column": 4},
   "goals":
   "pf✝¹ : NeZero 3\npf✝ : 0 < 3\nx : ℝ\nh : ∀ (i : Fin 3), badP i = boltzmannProb badLevels x i\n⊢ False",
   "endPos": {"line": 228, "column": 37}},
  {"usedConstants":
   ["Iff.mpr",
    "GroupWithZero.toMonoidWithZero",
    "Real.partialOrder",
    "Real",
    "Preorder.toLT",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "GroupWithZero.toDivisionMonoid",
    "InvOneClass.toOne",
    "GroupWithZero.toDivInvMonoid",
    "DivInvOneMonoid.toInvOneClass",
    "MulZeroClass.toMul",
    "PartialOrder.toPreorder",
    "DivisionSemiring.toGroupWithZero",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "DivisionMonoid.toDivInvOneMonoid",
    "Real.semiring",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Field.toSemifield",
    "Semifield.toDivisionSemiring",
    "MonoidWithZero.toMulZeroOneClass",
    "Real.normedCommRing",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "LT.lt",
    "one_div_pos",
    "DivInvMonoid.toDiv",
    "One.toOfNat1",
    "Zero.toOfNat0",
    "PosMulStrictMono.toPosMulReflectLE",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "MulZeroOneClass.toMulZeroClass",
    "OfNat.ofNat",
    "Real.instField",
    "IsStrictOrderedRing.toPosMulStrictMono",
    "Real.linearOrder",
    "MulZeroClass.toZero",
    "PosMulReflectLE.toPosMulReflectLT",
    "Real.instIsStrictOrderedRing"],
   "tactic": "exact one_div_pos.mpr hT",
   "proofState": 78,
   "pos": {"line": 232, "column": 2},
   "goals": "T : ℝ\nhT : 0 < T\n⊢ 0 < 1 / T",
   "endPos": {"line": 232, "column": 26}},
  {"usedConstants":
   ["Iff.mpr",
    "GroupWithZero.toMonoidWithZero",
    "Real.partialOrder",
    "Real",
    "Preorder.toLT",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "GroupWithZero.toDivisionMonoid",
    "InvOneClass.toOne",
    "GroupWithZero.toDivInvMonoid",
    "DivInvOneMonoid.toInvOneClass",
    "MulZeroClass.toMul",
    "Real.instZero",
    "Real.instDivInvMonoid",
    "PartialOrder.toPreorder",
    "le_of_lt",
    "DivisionSemiring.toGroupWithZero",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "DivisionMonoid.toDivInvOneMonoid",
    "Real.semiring",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Field.toSemifield",
    "Real.instOne",
    "Semifield.toDivisionSemiring",
    "MonoidWithZero.toMulZeroOneClass",
    "Real.normedCommRing",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "LT.lt",
    "one_div_pos",
    "DivInvMonoid.toDiv",
    "One.toOfNat1",
    "Zero.toOfNat0",
    "PosMulStrictMono.toPosMulReflectLE",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "MulZeroOneClass.toMulZeroClass",
    "OfNat.ofNat",
    "Real.instField",
    "IsStrictOrderedRing.toPosMulStrictMono",
    "Real.instPreorder",
    "Real.linearOrder",
    "MulZeroClass.toZero",
    "PosMulReflectLE.toPosMulReflectLT",
    "Real.instIsStrictOrderedRing"],
   "tactic": "exact le_of_lt (one_div_pos.mpr hT)",
   "proofState": 79,
   "pos": {"line": 236, "column": 2},
   "goals": "T : ℝ\nhT : 0 < T\n⊢ 0 ≤ 1 / T",
   "endPos": {"line": 236, "column": 37}},
  {"usedConstants":
   ["InnerProductSpace.toNormedSpace",
    "NormedCommRing.toSeminormedCommRing",
    "ProbDist.p",
    "Real",
    "instHDiv",
    "HMul.hMul",
    "Finset.univ",
    "ProbDist",
    "Real.denselyNormedField",
    "Real.instRCLike",
    "deriv",
    "Real.instDivInvMonoid",
    "NormedSpace.toModule",
    "PseudoMetricSpace.toUniformSpace",
    "internalEnergy",
    "id",
    "HDiv.hDiv",
    "one_div_nonneg_of_pos",
    "Real.instAddCommGroup",
    "Real.log",
    "Fin.fintype",
    "Real.instOne",
    "Real.normedCommRing",
    "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
    "Real.instMul",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "Real.pseudoMetricSpace",
    "Real.normedField",
    "DenselyNormedField.toNontriviallyNormedField",
    "boltzmannDist",
    "SeminormedCommRing.toNonUnitalSeminormedCommRing",
    "OfNat.ofNat",
    "Fin",
    "UniformSpace.toTopologicalSpace",
    "Eq",
    "EnergyLevels.ε",
    "partitionFunction",
    "Finset.sum",
    "Neg.neg",
    "RCLike.toInnerProductSpaceReal",
    "instHMul"],
   "tactic": "unfold internalEnergy boltzmannDist",
   "proofState": 80,
   "pos": {"line": 244, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\n⊢ let β := 1 / T;\n  let dist := boltzmannDist levels β ⋯;\n  internalEnergy levels dist = -deriv (fun β' => log (partitionFunction levels β')) (1 / T)",
   "endPos": {"line": 244, "column": 37}},
  {"usedConstants": ["Nat"],
   "tactic": "generalize_proofs at *",
   "proofState": 81,
   "pos": {"line": 245, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\n⊢ let β := 1 / T;\n  let dist := { p := boltzmannProb levels β, p_nonneg := ⋯, p_sum_one := ⋯ };\n  ∑ i, dist.p i * levels.ε i = -deriv (fun β' => log (partitionFunction levels β')) (1 / T)",
   "endPos": {"line": 245, "column": 24}},
  {"usedConstants":
   ["InnerProductSpace.toNormedSpace",
    "NormedCommRing.toSeminormedCommRing",
    "ProbDist.p",
    "Real",
    "instHDiv",
    "HMul.hMul",
    "Finset.univ",
    "ProbDist",
    "Real.denselyNormedField",
    "Real.instRCLike",
    "deriv",
    "Real.instDivInvMonoid",
    "NormedSpace.toModule",
    "PseudoMetricSpace.toUniformSpace",
    "id",
    "HDiv.hDiv",
    "Real.exp",
    "Real.instAddCommGroup",
    "Real.log",
    "ProbDist.mk",
    "Fin.fintype",
    "Real.instOne",
    "Real.normedCommRing",
    "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
    "Real.instMul",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "Real.pseudoMetricSpace",
    "Real.normedField",
    "DenselyNormedField.toNontriviallyNormedField",
    "SeminormedCommRing.toNonUnitalSeminormedCommRing",
    "OfNat.ofNat",
    "Fin",
    "UniformSpace.toTopologicalSpace",
    "Eq",
    "EnergyLevels.ε",
    "partitionFunction",
    "Finset.sum",
    "Neg.neg",
    "boltzmannProb",
    "RCLike.toInnerProductSpaceReal",
    "instHMul"],
   "tactic": "unfold partitionFunction boltzmannProb",
   "proofState": 82,
   "pos": {"line": 246, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\npf✝¹ : ∀ (i : Fin w), 0 ≤ boltzmannProb levels (1 / T) i\npf✝ : ∑ i, boltzmannProb levels (1 / T) i = 1\n⊢ let β := 1 / T;\n  let dist := { p := boltzmannProb levels β, p_nonneg := pf✝¹, p_sum_one := pf✝ };\n  ∑ i, dist.p i * levels.ε i = -deriv (fun β' => log (partitionFunction levels β')) (1 / T)",
   "endPos": {"line": 246, "column": 40}},
  {"usedConstants":
   ["InnerProductSpace.toNormedSpace",
    "NormedCommRing.toSeminormedCommRing",
    "ProbDist.p",
    "Real",
    "instHDiv",
    "HMul.hMul",
    "Finset.univ",
    "ProbDist",
    "Real.denselyNormedField",
    "Real.instRCLike",
    "deriv",
    "Real.instDivInvMonoid",
    "NormedSpace.toModule",
    "PseudoMetricSpace.toUniformSpace",
    "id",
    "HDiv.hDiv",
    "Real.exp",
    "Real.instAddCommGroup",
    "Real.log",
    "ProbDist.mk",
    "Fin.fintype",
    "Real.instOne",
    "Real.normedCommRing",
    "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
    "Real.instMul",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "Real.pseudoMetricSpace",
    "Real.normedField",
    "DenselyNormedField.toNontriviallyNormedField",
    "SeminormedCommRing.toNonUnitalSeminormedCommRing",
    "OfNat.ofNat",
    "Fin",
    "UniformSpace.toTopologicalSpace",
    "Eq",
    "EnergyLevels.ε",
    "partitionFunction",
    "Finset.sum",
    "Neg.neg",
    "RCLike.toInnerProductSpaceReal",
    "instHMul"],
   "tactic": "unfold partitionFunction",
   "proofState": 83,
   "pos": {"line": 247, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\npf✝¹ : ∀ (i : Fin w), 0 ≤ boltzmannProb levels (1 / T) i\npf✝ : ∑ i, boltzmannProb levels (1 / T) i = 1\n⊢ let β := 1 / T;\n  let dist := { p := fun i => rexp (-β * levels.ε i) / partitionFunction levels β, p_nonneg := pf✝¹, p_sum_one := pf✝ };\n  ∑ i, dist.p i * levels.ε i = -deriv (fun β' => log (∑ i, rexp (-β' * levels.ε i))) (1 / T)",
   "endPos": {"line": 247, "column": 26}},
  {"usedConstants":
   ["Eq.mpr",
    "InnerProductSpace.toNormedSpace",
    "NormedCommRing.toSeminormedCommRing",
    "ProbDist.p",
    "Real",
    "instHDiv",
    "HMul.hMul",
    "Finset.univ",
    "deriv.log",
    "ProbDist",
    "Real.denselyNormedField",
    "Real.instRCLike",
    "congrArg",
    "deriv",
    "Real.instDivInvMonoid",
    "NormedSpace.toModule",
    "PseudoMetricSpace.toUniformSpace",
    "id",
    "HDiv.hDiv",
    "Real.exp",
    "Real.instAddCommGroup",
    "Real.log",
    "ProbDist.mk",
    "Fin.fintype",
    "Real.instOne",
    "Real.normedCommRing",
    "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
    "Real.instMul",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "Real.pseudoMetricSpace",
    "Real.normedField",
    "DenselyNormedField.toNontriviallyNormedField",
    "NormedField.toNormedSpace",
    "SeminormedCommRing.toNonUnitalSeminormedCommRing",
    "OfNat.ofNat",
    "Fin",
    "UniformSpace.toTopologicalSpace",
    "Eq",
    "EnergyLevels.ε",
    "Finset.sum",
    "Neg.neg",
    "RCLike.toInnerProductSpaceReal",
    "instHMul"],
   "tactic": "rw [deriv.log]",
   "proofState": 84,
   "pos": {"line": 247, "column": 28},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\npf✝¹ : ∀ (i : Fin w), 0 ≤ boltzmannProb levels (1 / T) i\npf✝ : ∑ i, boltzmannProb levels (1 / T) i = 1\n⊢ let β := 1 / T;\n  let dist :=\n    { p := fun i => rexp (-β * levels.ε i) / ∑ i, rexp (-β * levels.ε i), p_nonneg := pf✝¹, p_sum_one := pf✝ };\n  ∑ i, dist.p i * levels.ε i = -deriv (fun β' => log (∑ i, rexp (-β' * levels.ε i))) (1 / T)",
   "endPos": {"line": 247, "column": 44}},
  {"usedConstants":
   ["deriv_exp",
    "NormedCommRing.toNormedRing",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
    "Eq.mpr",
    "InnerProductSpace.toNormedSpace",
    "NegZeroClass.toNeg",
    "NormedCommRing.toSeminormedCommRing",
    "differentiableAt_fun_id._simp_1",
    "MulOne.toOne",
    "ProbDist.p",
    "Real",
    "DivInvMonoid.toInv",
    "deriv_fun_sum",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "differentiableAt_fun_neg_iff._simp_1",
    "NormedRing.toRing",
    "RCLike.toNormedAlgebra",
    "HMul.hMul",
    "Finset.univ",
    "deriv_const'",
    "Ring.toNonAssocRing",
    "ProbDist",
    "Real.denselyNormedField",
    "Real.instAddMonoid",
    "Monoid.toMulOneClass",
    "Real.instRCLike",
    "congrArg",
    "deriv_fun_mul",
    "DifferentiableAt",
    "Finset",
    "deriv",
    "Real.instDivInvMonoid",
    "deriv.fun_neg'",
    "NormedSpace.toModule",
    "AddMonoid.toAddZeroClass",
    "AddGroupWithOne.toAddMonoidWithOne",
    "deriv_id''",
    "PseudoMetricSpace.toUniformSpace",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Membership.mem",
    "NormedRing.toNonUnitalNormedRing",
    "AddZeroClass.toAddZero",
    "Real.semiring",
    "differentiableAt_const._simp_1",
    "id",
    "Distrib.toAdd",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "DivInvMonoid.toMonoid",
    "Real.normedAddCommGroup",
    "Real.instRing",
    "CommMagma.toMul",
    "SubtractionMonoid.toSubNegZeroMonoid",
    "NonAssocSemiring.toMulZeroOneClass",
    "Mathlib.Meta.NormNum.isNat_ofNat",
    "Finset.instMembership",
    "imp_self._simp_1",
    "Real.exp",
    "SubNegZeroMonoid.toNegZeroClass",
    "Real.instAddCommGroup",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "SubtractionCommMonoid.toSubtractionMonoid",
    "NonAssocRing.toNonUnitalNonAssocRing",
    "ProbDist.mk",
    "Fin.fintype",
    "MulZeroClass.mul_zero",
    "MulZeroOneClass.toMulOneClass",
    "SubtractionCommMonoid.toAddCommMonoid",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "Real.instOne",
    "NonUnitalNormedRing.toNormedAddCommGroup",
    "AddMonoidWithOne.toOne",
    "AddZero.toZero",
    "funext",
    "instHAdd",
    "MulOneClass.toMulOne",
    "Inv.inv",
    "SeminormedAddCommGroup.toPseudoMetricSpace",
    "Real.normedCommRing",
    "Distrib.toMul",
    "HAdd.hAdd",
    "NormedAlgebra.toNormedSpace",
    "congrFun",
    "DifferentiableAt.fun_mul._simp_1",
    "implies_congr",
    "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
    "Real.instMul",
    "NonUnitalNonAssocCommSemiring.toCommMagma",
    "congr",
    "NormedRing.toSeminormedRing",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "one_div",
    "True",
    "Real.instNeg",
    "Mathlib.Meta.NormNum.IsNat.to_eq",
    "DivInvMonoid.toDiv",
    "eq_true",
    "mul_comm",
    "NonUnitalNormedCommRing.toNonUnitalNormedRing",
    "SeminormedCommRing.toSeminormedRing",
    "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
    "of_eq_true",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Zero.toOfNat0",
    "NormedAddCommGroup.toAddCommGroup",
    "Eq.refl",
    "NontriviallyNormedField.toNormedField",
    "neg_mul",
    "Finset.mem_univ._simp_1",
    "Real.pseudoMetricSpace",
    "Real.normedField",
    "DenselyNormedField.toNontriviallyNormedField",
    "NormedField.toNormedSpace",
    "implies_true",
    "ESeminormedAddCommMonoid.toAddCommMonoid",
    "SeminormedRing.toPseudoMetricSpace",
    "Nat.cast_zero",
    "AddMonoidWithOne.toAddMonoid",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "NormedField.toNormedCommRing",
    "HasDistribNeg.toInvolutiveNeg",
    "AddCommGroup.toDivisionAddCommMonoid",
    "SeminormedCommRing.toNonUnitalSeminormedCommRing",
    "InvolutiveNeg.toNeg",
    "add_zero",
    "OfNat.ofNat",
    "Finset.sum_neg_distrib",
    "Fin",
    "NormedAddCommGroup.toSeminormedAddCommGroup",
    "NonUnitalNormedRing.toNonUnitalSeminormedRing",
    "UniformSpace.toTopologicalSpace",
    "NegZeroClass.toZero",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "EnergyLevels.ε",
    "Nat.cast_one",
    "ENormedAddCommMonoid.toESeminormedAddCommMonoid",
    "Ring.toAddGroupWithOne",
    "Finset.sum_congr",
    "Finset.sum",
    "Neg.neg",
    "one_mul",
    "RCLike.toInnerProductSpaceReal",
    "Eq.trans",
    "MulZeroClass.toZero",
    "True.intro",
    "DifferentiableAt.exp._simp_1",
    "instHMul",
    "forall_congr",
    "NormedAddCommGroup.toENormedAddCommMonoid"],
   "tactic": "norm_num [mul_comm]",
   "proofState": 85,
   "pos": {"line": 247, "column": 49},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\npf✝¹ : ∀ (i : Fin w), 0 ≤ boltzmannProb levels (1 / T) i\npf✝ : ∑ i, boltzmannProb levels (1 / T) i = 1\n⊢ let β := 1 / T;\n  let dist :=\n    { p := fun i => rexp (-β * levels.ε i) / ∑ i, rexp (-β * levels.ε i), p_nonneg := pf✝¹, p_sum_one := pf✝ };\n  ∑ i, dist.p i * levels.ε i =\n    -(deriv (fun β' => ∑ i, rexp (-β' * levels.ε i)) (1 / T) / ∑ i, rexp (-(1 / T) * levels.ε i))",
   "endPos": {"line": 247, "column": 70}},
  {"usedConstants":
   ["NormedCommRing.toNormedRing",
    "InnerProductSpace.toNormedSpace",
    "NegZeroClass.toNeg",
    "NormedCommRing.toSeminormedCommRing",
    "differentiableAt_fun_id._simp_1",
    "MulOne.toOne",
    "Real",
    "DivInvMonoid.toInv",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "differentiableAt_fun_neg_iff._simp_1",
    "NormedRing.toRing",
    "RCLike.toNormedAlgebra",
    "HMul.hMul",
    "Finset.univ",
    "Ring.toNonAssocRing",
    "Real.denselyNormedField",
    "Monoid.toMulOneClass",
    "Real.instRCLike",
    "congrArg",
    "DifferentiableAt",
    "Finset",
    "Real.instDivInvMonoid",
    "NormedSpace.toModule",
    "PseudoMetricSpace.toUniformSpace",
    "Membership.mem",
    "NormedRing.toNonUnitalNormedRing",
    "differentiableAt_const._simp_1",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "DivInvMonoid.toMonoid",
    "Real.normedAddCommGroup",
    "SubtractionMonoid.toSubNegZeroMonoid",
    "Finset.instMembership",
    "imp_self._simp_1",
    "Real.exp",
    "SubNegZeroMonoid.toNegZeroClass",
    "Real.instAddCommGroup",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "SubtractionCommMonoid.toSubtractionMonoid",
    "NonAssocRing.toNonUnitalNonAssocRing",
    "Fin.fintype",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "NonUnitalNormedRing.toNormedAddCommGroup",
    "funext",
    "MulOneClass.toMulOne",
    "Inv.inv",
    "SeminormedAddCommGroup.toPseudoMetricSpace",
    "Real.normedCommRing",
    "Distrib.toMul",
    "NormedAlgebra.toNormedSpace",
    "DifferentiableAt.fun_mul._simp_1",
    "implies_congr",
    "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
    "Real.instMul",
    "congr",
    "NormedRing.toSeminormedRing",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "one_div",
    "True",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "eq_true",
    "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
    "of_eq_true",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "NormedAddCommGroup.toAddCommGroup",
    "Eq.refl",
    "NontriviallyNormedField.toNormedField",
    "neg_mul",
    "Finset.mem_univ._simp_1",
    "Real.pseudoMetricSpace",
    "Real.normedField",
    "DenselyNormedField.toNontriviallyNormedField",
    "NormedField.toNormedSpace",
    "implies_true",
    "SeminormedRing.toPseudoMetricSpace",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "HasDistribNeg.toInvolutiveNeg",
    "DifferentiableAt.fun_sum._simp_1",
    "AddCommGroup.toDivisionAddCommMonoid",
    "SeminormedCommRing.toNonUnitalSeminormedCommRing",
    "InvolutiveNeg.toNeg",
    "OfNat.ofNat",
    "Fin",
    "NormedAddCommGroup.toSeminormedAddCommGroup",
    "NonUnitalNormedRing.toNonUnitalSeminormedRing",
    "UniformSpace.toTopologicalSpace",
    "EnergyLevels.ε",
    "Finset.sum_congr",
    "Finset.sum",
    "Neg.neg",
    "RCLike.toInnerProductSpaceReal",
    "Eq.trans",
    "True.intro",
    "DifferentiableAt.exp._simp_1",
    "instHMul",
    "forall_congr"],
   "tactic": "norm_num [mul_comm]",
   "proofState": 86,
   "pos": {"line": 247, "column": 49},
   "goals":
   "case hf\nw : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\npf✝¹ : ∀ (i : Fin w), 0 ≤ boltzmannProb levels (1 / T) i\npf✝ : ∑ i, boltzmannProb levels (1 / T) i = 1\n⊢ DifferentiableAt ℝ (fun β' => ∑ i, rexp (-β' * levels.ε i)) (1 / T)",
   "endPos": {"line": 247, "column": 70}},
  {"usedConstants":
   ["Eq.mpr",
    "MulOne.toOne",
    "Real",
    "DivInvMonoid.toInv",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "Finset.univ",
    "Real.instZero",
    "Monoid.toMulOneClass",
    "congrArg",
    "Finset",
    "Real.instDivInvMonoid",
    "Membership.mem",
    "id",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "DivInvMonoid.toMonoid",
    "Ne",
    "Finset.instMembership",
    "Real.exp",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Fin.fintype",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "Real.instOne",
    "MulOneClass.toMulOne",
    "Inv.inv",
    "Real.normedCommRing",
    "Distrib.toMul",
    "Real.instMul",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "one_div",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Zero.toOfNat0",
    "Eq.refl",
    "neg_mul",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "HasDistribNeg.toInvolutiveNeg",
    "InvolutiveNeg.toNeg",
    "OfNat.ofNat",
    "Fin",
    "Eq",
    "EnergyLevels.ε",
    "Not",
    "Finset.sum_congr",
    "Finset.sum",
    "Neg.neg",
    "Eq.trans",
    "instHMul"],
   "tactic": "norm_num [mul_comm]",
   "proofState": 87,
   "pos": {"line": 247, "column": 49},
   "goals":
   "case hx\nw : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\npf✝¹ : ∀ (i : Fin w), 0 ≤ boltzmannProb levels (1 / T) i\npf✝ : ∑ i, boltzmannProb levels (1 / T) i = 1\n⊢ ∑ i, rexp (-(1 / T) * levels.ε i) ≠ 0",
   "endPos": {"line": 247, "column": 70}},
  {"usedConstants":
   ["NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
    "Finset.mul_sum",
    "NegZeroClass.toNeg",
    "Semigroup.toMul",
    "Real",
    "DivInvMonoid.toInv",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "Finset.univ",
    "Monoid.toMulOneClass",
    "congrArg",
    "Finset",
    "Real.instDivInvMonoid",
    "mul_assoc",
    "Membership.mem",
    "neg_neg",
    "MulOne.toMul",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "DivInvMonoid.toMonoid",
    "CommMagma.toMul",
    "SubtractionMonoid.toSubNegZeroMonoid",
    "Finset.instMembership",
    "Real.exp",
    "SubNegZeroMonoid.toNegZeroClass",
    "Real.instAddCommGroup",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "SubtractionCommMonoid.toSubtractionMonoid",
    "div_eq_mul_inv",
    "Fin.fintype",
    "SubtractionCommMonoid.toAddCommMonoid",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "NonUnitalNonAssocSemiring.toAddCommMonoid",
    "MulOneClass.toMulOne",
    "Inv.inv",
    "Real.normedCommRing",
    "Distrib.toMul",
    "NonUnitalNonAssocCommSemiring.toCommMagma",
    "congr",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "True",
    "Real.instNeg",
    "eq_self",
    "DivInvMonoid.toDiv",
    "mul_comm",
    "of_eq_true",
    "Real.instAddCommMonoid",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Eq.refl",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "HasDistribNeg.toInvolutiveNeg",
    "AddCommGroup.toDivisionAddCommMonoid",
    "InvolutiveNeg.toNeg",
    "NonUnitalNonAssocSemiring",
    "Fin",
    "Real.instSemigroup",
    "Eq",
    "EnergyLevels.ε",
    "Finset.sum_congr",
    "Finset.sum",
    "Neg.neg",
    "Eq.trans",
    "mul_neg",
    "instHMul"],
   "tactic":
   "simp +decide [div_eq_mul_inv, mul_assoc, mul_comm, Finset.mul_sum _ _ _]",
   "proofState": 88,
   "pos": {"line": 248, "column": 4},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\npf✝¹ : ∀ (i : Fin w), 0 ≤ boltzmannProb levels (1 / T) i\npf✝ : ∑ i, boltzmannProb levels (1 / T) i = 1\n⊢ ∑ x, levels.ε x * (rexp (-(T⁻¹ * levels.ε x)) / ∑ x, rexp (-(T⁻¹ * levels.ε x))) =\n    -((-∑ x, levels.ε x * rexp (-(T⁻¹ * levels.ε x))) / ∑ x, rexp (-(T⁻¹ * levels.ε x)))",
   "endPos": {"line": 248, "column": 76}},
  {"usedConstants":
   ["Real.partialOrder",
    "Real",
    "DivInvMonoid.toInv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "Finset.univ",
    "Real.instZero",
    "Finset",
    "Real.instDivInvMonoid",
    "Membership.mem",
    "Finset.sum_pos",
    "Finset.univ_nonempty",
    "ne_of_gt",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "Finset.instMembership",
    "Real.exp",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Fin.fintype",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "Inv.inv",
    "Real.normedCommRing",
    "Distrib.toMul",
    "instNonemptyOfInhabited",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "Fin.instInhabited",
    "Real.instAddCommMonoid",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Zero.toOfNat0",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "HasDistribNeg.toInvolutiveNeg",
    "InvolutiveNeg.toNeg",
    "OfNat.ofNat",
    "Fin",
    "EnergyLevels.ε",
    "Finset.sum",
    "Neg.neg",
    "Real.instPreorder",
    "Real.exp_pos",
    "instHMul",
    "Real.instIsOrderedCancelAddMonoid"],
   "tactic":
   "exact ne_of_gt <| Finset.sum_pos (fun _ _ => Real.exp_pos _) Finset.univ_nonempty",
   "proofState": 89,
   "pos": {"line": 249, "column": 4},
   "goals":
   "case hx\nw : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\npf✝¹ : ∀ (i : Fin w), 0 ≤ boltzmannProb levels (1 / T) i\npf✝ : ∑ i, boltzmannProb levels (1 / T) i = 1\n⊢ ¬∑ x, rexp (-(T⁻¹ * levels.ε x)) = 0",
   "endPos": {"line": 249, "column": 87}},
  {"usedConstants": ["Real", "Eq.refl", "freeEnergy"],
   "tactic": "rfl",
   "proofState": 90,
   "pos": {"line": 254, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\n⊢ freeEnergy levels T = -T * log (partitionFunction levels (1 / T))",
   "endPos": {"line": 254, "column": 5}},
  {"usedConstants":
   ["NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
    "Finset.mem_univ",
    "Eq.mpr",
    "Finset.mul_sum",
    "GroupWithZero.toMonoidWithZero",
    "NegZeroClass.toNeg",
    "Nat.instCanonicallyOrderedAdd",
    "NonAssocSemiring.toAddCommMonoidWithOne",
    "MulOne.toOne",
    "ProbDist.p",
    "Real.partialOrder",
    "Semigroup.toMul",
    "Real",
    "DivInvMonoid.toInv",
    "neg_sub",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "Mathlib.Meta.NormNum.IsNat.to_isNNRat",
    "Mathlib.Tactic.RingNF.mul_neg",
    "GroupWithZero.toDivisionMonoid",
    "Real.log_exp",
    "HMul.hMul",
    "GroupWithZero.toDivInvMonoid",
    "CommRing.toNonUnitalCommRing",
    "DivisionCommMonoid.toDivisionMonoid",
    "Nat.rawCast",
    "Finset.univ",
    "DivInvOneMonoid.toInvOneClass",
    "Ring.toNonAssocRing",
    "MulZeroClass.toMul",
    "Mathlib.Tactic.Ring.mul_zero",
    "Mathlib.Tactic.Ring.mul_pf_left",
    "Real.instAddMonoid",
    "Monoid.toMulOneClass",
    "Real.instRCLike",
    "AddGroupWithOne.toAddGroup",
    "Mathlib.Tactic.Ring.add_pf_add_gt",
    "congrArg",
    "CommSemiring.toSemiring",
    "Mathlib.Tactic.Ring.inv_congr",
    "Finset",
    "Mathlib.Tactic.Ring.neg_congr",
    "Real.instDivInvMonoid",
    "Mathlib.Tactic.Ring.neg_zero",
    "Real.instSub",
    "Mathlib.Tactic.Ring.mul_pf_right",
    "AddMonoid.toAddZeroClass",
    "Int.rawCast",
    "mul_assoc",
    "Mathlib.Tactic.Ring.one_mul",
    "Real.instAddRightCancelSemigroup",
    "AddGroupWithOne.toAddMonoidWithOne",
    "HSub.hSub",
    "Mathlib.Tactic.Ring.zero_mul",
    "Mathlib.Meta.NormNum.IsNat.of_raw",
    "mul_left_inj._simp_4",
    "DivisionSemiring.toGroupWithZero",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Nat.instAddMonoid",
    "internalEnergy",
    "Mathlib.Tactic.Ring.instCommSemiringNat",
    "Membership.mem",
    "DivisionMonoid.toDivInvOneMonoid",
    "Finset.sum_pos",
    "inv_mul_eq_div",
    "Real.instCommSemigroup",
    "Monoid.toNatPow",
    "AddZeroClass.toAddZero",
    "Real.semiring",
    "Mathlib.Tactic.Ring.neg_mul",
    "ne_of_gt",
    "Mathlib.Tactic.Ring.sub_pf",
    "Fin.mk",
    "Mathlib.Tactic.Ring.neg_add",
    "id",
    "MulOne.toMul",
    "Distrib.toAdd",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "DivInvMonoid.toMonoid",
    "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
    "Int.ofNat",
    "CommMagma.toMul",
    "SubtractionMonoid.toSubNegZeroMonoid",
    "NonAssocSemiring.toMulZeroOneClass",
    "instOfNatNat",
    "one_div_nonneg_of_pos",
    "Int",
    "AddCommMonoidWithOne.toAddMonoidWithOne",
    "Mathlib.Tactic.Ring.sub_congr",
    "SubtractionMonoid.toSubNegMonoid",
    "Finset.instMembership",
    "Mathlib.Meta.NormNum.isInt_mul",
    "Mathlib.Tactic.Ring.atom_pf'",
    "Mathlib.Meta.NormNum.isNNRat_inv_pos",
    "Mathlib.Tactic.Ring.inv_mul",
    "boltzmannProb_sum_one",
    "mul_left_comm",
    "Real.exp",
    "Real.commRing",
    "SubNegZeroMonoid.toNegZeroClass",
    "Real.instAddCommGroup",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Mathlib.Tactic.Ring.add_pf_zero_add",
    "SubtractionCommMonoid.toSubtractionMonoid",
    "DivisionMonoid.toDivInvMonoid",
    "Real.log",
    "Field.toSemifield",
    "NonAssocRing.toNonUnitalNonAssocRing",
    "Mathlib.Tactic.Ring.mul_congr",
    "ProbDist.mk",
    "Fin.fintype",
    "MulZeroOneClass.toMulOneClass",
    "SubtractionCommMonoid.toAddCommMonoid",
    "Real.instAdd",
    "NonUnitalCommSemiring.toNonUnitalSemiring",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "Real.instOne",
    "SubNegMonoid.toSub",
    "NonUnitalNonAssocSemiring.toAddCommMonoid",
    "AddMonoidWithOne.toOne",
    "Mathlib.Tactic.Ring.add_mul",
    "Mathlib.Tactic.Ring.inv_single",
    "instHAdd",
    "MulOneClass.toMulOne",
    "Mathlib.Meta.NormNum.instAddMonoidWithOne'",
    "Mathlib.Tactic.Ring.add_pf_add_zero",
    "instHSub",
    "div_eq_iff",
    "Finset.sum_sub_distrib",
    "Inv.inv",
    "Mathlib.Tactic.RingNF.add_neg",
    "Semifield.toDivisionSemiring",
    "AddGroup.toSubNegMonoid",
    "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
    "MonoidWithZero.toMulZeroOneClass",
    "HPow.hPow",
    "Real.normedCommRing",
    "Distrib.toMul",
    "HAdd.hAdd",
    "NonUnitalCommRing.toNonUnitalCommSemiring",
    "pow_one",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Ring.toAddCommGroup",
    "Nat",
    "Real.instMul",
    "NonUnitalNonAssocCommSemiring.toCommMagma",
    "Mathlib.Tactic.Ring.div_congr",
    "congr",
    "Semifield.toCommGroupWithZero",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "one_div",
    "Nat.instCommSemiring",
    "CommSemigroup.toCommMagma",
    "Real.instNeg",
    "propext",
    "Exists.intro",
    "DivInvMonoid.toDiv",
    "Mathlib.Meta.NormNum.IsNNRat.to_isNat",
    "Nat.instPartialOrder",
    "mul_comm",
    "DivisionSemiring.toSemiring",
    "gibbsEntropy",
    "Mathlib.Tactic.Ring.add_pf_add_lt",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "NeZero.pos",
    "AddZero.toAdd",
    "Zero.toOfNat0",
    "Eq.refl",
    "CommGroupWithZero.toDivisionCommMonoid",
    "Mathlib.Meta.NormNum.IsInt.of_raw",
    "neg_mul",
    "InvOneClass.toInv",
    "instHPow",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "Mathlib.Tactic.RingNF.nat_rawCast_1",
    "MulZeroOneClass.toMulZeroClass",
    "HasDistribNeg.toInvolutiveNeg",
    "Mathlib.Tactic.RingNF.mul_assoc_rev",
    "SubNegMonoid.toAddMonoid",
    "CommRing.toRing",
    "mul_one",
    "boltzmannDist",
    "Mathlib.Tactic.Ring.atom_pf",
    "AddCommGroup.toDivisionAddCommMonoid",
    "InvolutiveNeg.toNeg",
    "add_zero",
    "Mathlib.Tactic.Ring.div_pf",
    "NonUnitalNonAssocSemiring",
    "boltzmannProb_nonneg",
    "OfNat.ofNat",
    "Eq.symm",
    "Mathlib.Tactic.RingNF.int_rawCast_neg",
    "Finset.sum_neg_distrib",
    "Fin",
    "Real.instSemigroup",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "EnergyLevels.ε",
    "partitionFunction",
    "RCLike.charZero_rclike",
    "Mathlib.Tactic.Ring.neg_one_mul",
    "Ring.toAddGroupWithOne",
    "Finset.sum_congr",
    "Finset.sum",
    "Neg.neg",
    "Real.instPreorder",
    "boltzmannProb",
    "sub_neg_eq_add",
    "MonoidWithZero.toMonoid",
    "rfl",
    "Mathlib.Tactic.Ring.mul_add",
    "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
    "Eq.trans",
    "Int.negOfNat",
    "mul_neg",
    "MulZeroClass.toZero",
    "Mathlib.Tactic.Ring.add_congr",
    "Real.instCommSemiring",
    "Mathlib.Meta.NormNum.IsNat.to_isInt",
    "Real.exp_pos",
    "Semiring.toMonoidWithZero",
    "instHMul",
    "AddRightCancelSemigroup.toIsRightCancelAdd",
    "Real.instIsOrderedCancelAddMonoid"],
   "tactic":
   "have h_gibbs_entropy :\n  gibbsEntropy (boltzmannDist levels (1 / T) (one_div_nonneg_of_pos hT)) =\n    (1 / T) * (internalEnergy levels (boltzmannDist levels (1 / T) (one_div_nonneg_of_pos hT))) +\n      Real.log (partitionFunction levels (1 / T)) :=\n  by unfold gibbsEntropy internalEnergy boltzmannDist; simp +decide [boltzmannProb, Finset.mul_sum _ _ _, mul_comm];\n  rw [Finset.sum_congr rfl fun i _ => by\n      rw [Real.log_div (by positivity)\n          (by exact ne_of_gt <| Finset.sum_pos (fun _ _ => Real.exp_pos _) ⟨i, Finset.mem_univ _⟩)]];\n  ring_nf; norm_num [mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _];\n  simp +decide [← Finset.mul_sum _ _ _, partitionFunction];\n  rw [inv_mul_eq_div,\n    div_eq_iff (ne_of_gt <| Finset.sum_pos (fun _ _ => Real.exp_pos _) ⟨⟨0, NeZero.pos w⟩, Finset.mem_univ _⟩)];",
   "proofState": 91,
   "pos": {"line": 266, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\n⊢ let β := 1 / T;\n  let dist := boltzmannDist levels β ⋯;\n  let U := internalEnergy levels dist;\n  let S := gibbsEntropy dist;\n  let F := freeEnergy levels T;\n  U = F + T * S",
   "endPos": {"line": 272, "column": 142}},
  {"usedConstants":
   ["ProbDist.p",
    "Real",
    "instHDiv",
    "HMul.hMul",
    "Finset.univ",
    "Real.instDivInvMonoid",
    "internalEnergy",
    "id",
    "HDiv.hDiv",
    "one_div_nonneg_of_pos",
    "Real.log",
    "Fin.fintype",
    "Real.instAdd",
    "Real.instOne",
    "instHAdd",
    "HAdd.hAdd",
    "Real.instMul",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "gibbsEntropy",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "boltzmannDist",
    "OfNat.ofNat",
    "Fin",
    "Eq",
    "EnergyLevels.ε",
    "partitionFunction",
    "Finset.sum",
    "Neg.neg",
    "instHMul"],
   "tactic": "unfold gibbsEntropy internalEnergy boltzmannDist",
   "proofState": 92,
   "pos": {"line": 267, "column": 4},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\n⊢ gibbsEntropy (boltzmannDist levels (1 / T) ⋯) =\n    1 / T * internalEnergy levels (boltzmannDist levels (1 / T) ⋯) + log (partitionFunction levels (1 / T))",
   "endPos": {"line": 267, "column": 52}},
  {"usedConstants":
   ["NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
    "Eq.mpr",
    "Finset.mul_sum",
    "MulOne.toOne",
    "ProbDist.p",
    "Real",
    "DivInvMonoid.toInv",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "Finset.univ",
    "Monoid.toMulOneClass",
    "congrArg",
    "Finset",
    "Real.instDivInvMonoid",
    "Membership.mem",
    "id",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "DivInvMonoid.toMonoid",
    "CommMagma.toMul",
    "one_div_nonneg_of_pos",
    "Finset.instMembership",
    "boltzmannProb_sum_one",
    "Real.exp",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Real.log",
    "ProbDist.mk",
    "Fin.fintype",
    "Real.instAdd",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "Real.instOne",
    "NonUnitalNonAssocSemiring.toAddCommMonoid",
    "instHAdd",
    "MulOneClass.toMulOne",
    "Inv.inv",
    "Real.normedCommRing",
    "Distrib.toMul",
    "HAdd.hAdd",
    "Real.instMul",
    "NonUnitalNonAssocCommSemiring.toCommMagma",
    "congr",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "one_div",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "mul_comm",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Eq.refl",
    "neg_mul",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "HasDistribNeg.toInvolutiveNeg",
    "InvolutiveNeg.toNeg",
    "NonUnitalNonAssocSemiring",
    "boltzmannProb_nonneg",
    "OfNat.ofNat",
    "Fin",
    "Eq",
    "EnergyLevels.ε",
    "partitionFunction",
    "Finset.sum_congr",
    "Finset.sum",
    "Neg.neg",
    "boltzmannProb",
    "Eq.trans",
    "instHMul"],
   "tactic": "simp +decide [boltzmannProb, Finset.mul_sum _ _ _, mul_comm]",
   "proofState": 93,
   "pos": {"line": 268, "column": 4},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\n⊢ -∑ i,\n        { p := boltzmannProb levels (1 / T), p_nonneg := ⋯, p_sum_one := ⋯ }.p i *\n          log ({ p := boltzmannProb levels (1 / T), p_nonneg := ⋯, p_sum_one := ⋯ }.p i) =\n    1 / T * ∑ i, { p := boltzmannProb levels (1 / T), p_nonneg := ⋯, p_sum_one := ⋯ }.p i * levels.ε i +\n      log (partitionFunction levels (1 / T))",
   "endPos": {"line": 268, "column": 64}},
  {"usedConstants":
   ["NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
    "Eq.mpr",
    "Real",
    "DivInvMonoid.toInv",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "Finset.univ",
    "congrArg",
    "Finset",
    "Real.instDivInvMonoid",
    "Real.instSub",
    "HSub.hSub",
    "Membership.mem",
    "id",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "CommMagma.toMul",
    "Finset.instMembership",
    "Real.exp",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Real.log",
    "Fin.fintype",
    "Real.instAdd",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "NonUnitalNonAssocSemiring.toAddCommMonoid",
    "instHAdd",
    "instHSub",
    "Inv.inv",
    "Real.normedCommRing",
    "Distrib.toMul",
    "HAdd.hAdd",
    "Real.instMul",
    "NonUnitalNonAssocCommSemiring.toCommMagma",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "Real.instAddCommMonoid",
    "NonUnitalNonAssocSemiring.toDistrib",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "HasDistribNeg.toInvolutiveNeg",
    "InvolutiveNeg.toNeg",
    "Fin",
    "Eq",
    "EnergyLevels.ε",
    "partitionFunction",
    "Finset.sum_congr",
    "Finset.sum",
    "Neg.neg",
    "rfl",
    "instHMul"],
   "tactic":
   "rw [Finset.sum_congr rfl fun i _ => by\n    rw [Real.log_div (by positivity)\n        (by exact ne_of_gt <| Finset.sum_pos (fun _ _ => Real.exp_pos _) ⟨i, Finset.mem_univ _⟩)]]",
   "proofState": 94,
   "pos": {"line": 269, "column": 4},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\n⊢ -∑ x,\n        rexp (-(T⁻¹ * levels.ε x)) / partitionFunction levels T⁻¹ *\n          log (rexp (-(T⁻¹ * levels.ε x)) / partitionFunction levels T⁻¹) =\n    ∑ i, T⁻¹ * (levels.ε i * (rexp (-(T⁻¹ * levels.ε i)) / partitionFunction levels T⁻¹)) +\n      log (partitionFunction levels T⁻¹)",
   "endPos": {"line": 269, "column": 178}},
  {"usedConstants":
   ["Finset.mem_univ",
    "Eq.mpr",
    "Real.partialOrder",
    "Real",
    "DivInvMonoid.toInv",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "Finset.univ",
    "Real.instZero",
    "congrArg",
    "Finset",
    "Real.instDivInvMonoid",
    "Real.instSub",
    "PartialOrder.toPreorder",
    "HSub.hSub",
    "Membership.mem",
    "Finset.sum_pos",
    "ne_of_gt",
    "id",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "Finset.instMembership",
    "Real.exp",
    "Real.log_div",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Real.log",
    "Fin.fintype",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "instHSub",
    "Inv.inv",
    "Real.normedCommRing",
    "Distrib.toMul",
    "Real.instMul",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "Real.instNeg",
    "Exists.intro",
    "DivInvMonoid.toDiv",
    "Real.instAddCommMonoid",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Zero.toOfNat0",
    "Eq.refl",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "HasDistribNeg.toInvolutiveNeg",
    "InvolutiveNeg.toNeg",
    "OfNat.ofNat",
    "Fin",
    "Eq",
    "EnergyLevels.ε",
    "partitionFunction",
    "Neg.neg",
    "Real.instPreorder",
    "Real.exp_pos",
    "instHMul",
    "Real.instIsOrderedCancelAddMonoid"],
   "tactic":
   "rw [Real.log_div (by positivity)\n    (by exact ne_of_gt <| Finset.sum_pos (fun _ _ => Real.exp_pos _) ⟨i, Finset.mem_univ _⟩)]",
   "proofState": 95,
   "pos": {"line": 269, "column": 44},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\ni : Fin w\nx✝ : i ∈ Finset.univ\n⊢ rexp (-(T⁻¹ * levels.ε i)) / partitionFunction levels T⁻¹ *\n      log (rexp (-(T⁻¹ * levels.ε i)) / partitionFunction levels T⁻¹) =\n    ?m.94 i",
   "endPos": {"line": 269, "column": 176}},
  {"usedConstants":
   ["Real.partialOrder",
    "Real",
    "DivInvMonoid.toInv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "Real.instZero",
    "Real.instDivInvMonoid",
    "PartialOrder.toPreorder",
    "ne_of_gt",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "Real.exp",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "Inv.inv",
    "Real.normedCommRing",
    "Distrib.toMul",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Zero.toOfNat0",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "HasDistribNeg.toInvolutiveNeg",
    "InvolutiveNeg.toNeg",
    "OfNat.ofNat",
    "EnergyLevels.ε",
    "Neg.neg",
    "Real.exp_pos",
    "instHMul"],
   "tactic": "positivity",
   "proofState": 96,
   "pos": {"line": 269, "column": 67},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\ni : Fin w\nx✝ : i ∈ Finset.univ\n⊢ rexp (-(T⁻¹ * levels.ε i)) ≠ 0",
   "endPos": {"line": 269, "column": 77}},
  {"usedConstants":
   ["Finset.mem_univ",
    "Real.partialOrder",
    "Real",
    "DivInvMonoid.toInv",
    "HMul.hMul",
    "Finset.univ",
    "Real.instZero",
    "Finset",
    "Real.instDivInvMonoid",
    "Membership.mem",
    "Finset.sum_pos",
    "ne_of_gt",
    "Finset.instMembership",
    "Real.exp",
    "Fin.fintype",
    "Inv.inv",
    "Real.instMul",
    "Real.instNeg",
    "Exists.intro",
    "Real.instAddCommMonoid",
    "Zero.toOfNat0",
    "OfNat.ofNat",
    "Fin",
    "EnergyLevels.ε",
    "partitionFunction",
    "Neg.neg",
    "Real.instPreorder",
    "Real.exp_pos",
    "instHMul",
    "Real.instIsOrderedCancelAddMonoid"],
   "tactic":
   "exact ne_of_gt <| Finset.sum_pos (fun _ _ => Real.exp_pos _) ⟨i, Finset.mem_univ _⟩",
   "proofState": 97,
   "pos": {"line": 269, "column": 85},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\ni : Fin w\nx✝ : i ∈ Finset.univ\n⊢ partitionFunction levels T⁻¹ ≠ 0",
   "endPos": {"line": 269, "column": 172}},
  {"usedConstants":
   ["NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
    "Eq.mpr",
    "NegZeroClass.toNeg",
    "NonAssocSemiring.toAddCommMonoidWithOne",
    "MulOne.toOne",
    "Real",
    "DivInvMonoid.toInv",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "Mathlib.Meta.NormNum.IsNat.to_isNNRat",
    "Mathlib.Tactic.RingNF.mul_neg",
    "GroupWithZero.toDivisionMonoid",
    "HMul.hMul",
    "DivisionCommMonoid.toDivisionMonoid",
    "Nat.rawCast",
    "Finset.univ",
    "DivInvOneMonoid.toInvOneClass",
    "Ring.toNonAssocRing",
    "Mathlib.Tactic.Ring.mul_zero",
    "Mathlib.Tactic.Ring.mul_pf_left",
    "Real.instAddMonoid",
    "Real.instRCLike",
    "AddGroupWithOne.toAddGroup",
    "Mathlib.Tactic.Ring.add_pf_add_gt",
    "congrArg",
    "CommSemiring.toSemiring",
    "Mathlib.Tactic.Ring.inv_congr",
    "Finset",
    "Mathlib.Tactic.Ring.neg_congr",
    "Real.instDivInvMonoid",
    "Mathlib.Tactic.Ring.neg_zero",
    "Real.instSub",
    "Mathlib.Tactic.Ring.mul_pf_right",
    "AddMonoid.toAddZeroClass",
    "Int.rawCast",
    "Mathlib.Tactic.Ring.one_mul",
    "AddGroupWithOne.toAddMonoidWithOne",
    "HSub.hSub",
    "Mathlib.Tactic.Ring.zero_mul",
    "Mathlib.Meta.NormNum.IsNat.of_raw",
    "DivisionSemiring.toGroupWithZero",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Mathlib.Tactic.Ring.instCommSemiringNat",
    "Membership.mem",
    "DivisionMonoid.toDivInvOneMonoid",
    "Monoid.toNatPow",
    "Real.semiring",
    "Mathlib.Tactic.Ring.neg_mul",
    "Mathlib.Tactic.Ring.sub_pf",
    "Mathlib.Tactic.Ring.neg_add",
    "id",
    "MulOne.toMul",
    "Distrib.toAdd",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "Int.ofNat",
    "CommMagma.toMul",
    "SubtractionMonoid.toSubNegZeroMonoid",
    "NonAssocSemiring.toMulZeroOneClass",
    "instOfNatNat",
    "Int",
    "AddCommMonoidWithOne.toAddMonoidWithOne",
    "Mathlib.Tactic.Ring.sub_congr",
    "Finset.instMembership",
    "Mathlib.Meta.NormNum.isInt_mul",
    "Mathlib.Tactic.Ring.atom_pf'",
    "Mathlib.Meta.NormNum.isNNRat_inv_pos",
    "Mathlib.Tactic.Ring.inv_mul",
    "Real.exp",
    "Real.commRing",
    "SubNegZeroMonoid.toNegZeroClass",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Mathlib.Tactic.Ring.add_pf_zero_add",
    "SubtractionCommMonoid.toSubtractionMonoid",
    "Real.log",
    "Field.toSemifield",
    "NonAssocRing.toNonUnitalNonAssocRing",
    "Mathlib.Tactic.Ring.mul_congr",
    "Fin.fintype",
    "MulZeroOneClass.toMulOneClass",
    "Real.instAdd",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "SubNegMonoid.toSub",
    "NonUnitalNonAssocSemiring.toAddCommMonoid",
    "AddMonoidWithOne.toOne",
    "Mathlib.Tactic.Ring.add_mul",
    "Mathlib.Tactic.Ring.inv_single",
    "instHAdd",
    "MulOneClass.toMulOne",
    "Mathlib.Meta.NormNum.instAddMonoidWithOne'",
    "Mathlib.Tactic.Ring.add_pf_add_zero",
    "instHSub",
    "Inv.inv",
    "Mathlib.Tactic.RingNF.add_neg",
    "Semifield.toDivisionSemiring",
    "AddGroup.toSubNegMonoid",
    "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
    "HPow.hPow",
    "Real.normedCommRing",
    "Distrib.toMul",
    "HAdd.hAdd",
    "pow_one",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Ring.toAddCommGroup",
    "Nat",
    "Real.instMul",
    "NonUnitalNonAssocCommSemiring.toCommMagma",
    "Mathlib.Tactic.Ring.div_congr",
    "congr",
    "Semifield.toCommGroupWithZero",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "Nat.instCommSemiring",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "Mathlib.Meta.NormNum.IsNNRat.to_isNat",
    "DivisionSemiring.toSemiring",
    "Mathlib.Tactic.Ring.add_pf_add_lt",
    "Real.instAddCommMonoid",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Zero.toOfNat0",
    "Eq.refl",
    "CommGroupWithZero.toDivisionCommMonoid",
    "Mathlib.Meta.NormNum.IsInt.of_raw",
    "InvOneClass.toInv",
    "instHPow",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "Mathlib.Tactic.RingNF.nat_rawCast_1",
    "HasDistribNeg.toInvolutiveNeg",
    "Mathlib.Tactic.RingNF.mul_assoc_rev",
    "CommRing.toRing",
    "mul_one",
    "Mathlib.Tactic.Ring.atom_pf",
    "AddCommGroup.toDivisionAddCommMonoid",
    "InvolutiveNeg.toNeg",
    "add_zero",
    "Mathlib.Tactic.Ring.div_pf",
    "OfNat.ofNat",
    "Mathlib.Tactic.RingNF.int_rawCast_neg",
    "Fin",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "EnergyLevels.ε",
    "partitionFunction",
    "RCLike.charZero_rclike",
    "Mathlib.Tactic.Ring.neg_one_mul",
    "Ring.toAddGroupWithOne",
    "Finset.sum_congr",
    "Finset.sum",
    "Neg.neg",
    "MonoidWithZero.toMonoid",
    "Mathlib.Tactic.Ring.mul_add",
    "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
    "Eq.trans",
    "Int.negOfNat",
    "MulZeroClass.toZero",
    "Mathlib.Tactic.Ring.add_congr",
    "Real.instCommSemiring",
    "Mathlib.Meta.NormNum.IsNat.to_isInt",
    "Semiring.toMonoidWithZero",
    "instHMul"],
   "tactic": "ring_nf",
   "proofState": 98,
   "pos": {"line": 269, "column": 181},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\n⊢ -∑ i,\n        rexp (-(T⁻¹ * levels.ε i)) / partitionFunction levels T⁻¹ *\n          (log (rexp (-(T⁻¹ * levels.ε i))) - log (partitionFunction levels T⁻¹)) =\n    ∑ i, T⁻¹ * (levels.ε i * (rexp (-(T⁻¹ * levels.ε i)) / partitionFunction levels T⁻¹)) +\n      log (partitionFunction levels T⁻¹)",
   "endPos": {"line": 269, "column": 188}},
  {"usedConstants":
   ["NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
    "Eq.mpr",
    "NegZeroClass.toNeg",
    "Semigroup.toMul",
    "Real",
    "neg_sub",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "Real.log_exp",
    "HMul.hMul",
    "DivisionCommMonoid.toDivisionMonoid",
    "Finset.univ",
    "DivInvOneMonoid.toInvOneClass",
    "Ring.toNonAssocRing",
    "AddGroupWithOne.toAddGroup",
    "congrArg",
    "CommSemiring.toSemiring",
    "Finset",
    "AddMonoid.toAddZeroClass",
    "mul_assoc",
    "Real.instAddRightCancelSemigroup",
    "HSub.hSub",
    "mul_left_inj._simp_4",
    "Membership.mem",
    "DivisionMonoid.toDivInvOneMonoid",
    "Real.instCommSemigroup",
    "AddZeroClass.toAddZero",
    "id",
    "Distrib.toAdd",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "CommMagma.toMul",
    "SubtractionMonoid.toSubNegZeroMonoid",
    "SubtractionMonoid.toSubNegMonoid",
    "Finset.instMembership",
    "mul_left_comm",
    "Real.exp",
    "Real.commRing",
    "SubNegZeroMonoid.toNegZeroClass",
    "Real.instAddCommGroup",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "SubtractionCommMonoid.toSubtractionMonoid",
    "Real.log",
    "Field.toSemifield",
    "NonAssocRing.toNonUnitalNonAssocRing",
    "Fin.fintype",
    "SubtractionCommMonoid.toAddCommMonoid",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "SubNegMonoid.toSub",
    "NonUnitalNonAssocSemiring.toAddCommMonoid",
    "instHAdd",
    "instHSub",
    "Finset.sum_sub_distrib",
    "Inv.inv",
    "AddGroup.toSubNegMonoid",
    "Real.normedCommRing",
    "Distrib.toMul",
    "HAdd.hAdd",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Ring.toAddCommGroup",
    "NonUnitalNonAssocCommSemiring.toCommMagma",
    "congr",
    "Semifield.toCommGroupWithZero",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "CommSemigroup.toCommMagma",
    "mul_comm",
    "Real.instAddCommMonoid",
    "NonUnitalNonAssocSemiring.toDistrib",
    "AddZero.toAdd",
    "Eq.refl",
    "CommGroupWithZero.toDivisionCommMonoid",
    "neg_mul",
    "InvOneClass.toInv",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "HasDistribNeg.toInvolutiveNeg",
    "SubNegMonoid.toAddMonoid",
    "CommRing.toRing",
    "AddCommGroup.toDivisionAddCommMonoid",
    "InvolutiveNeg.toNeg",
    "Finset.sum_neg_distrib",
    "Fin",
    "Real.instSemigroup",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "EnergyLevels.ε",
    "partitionFunction",
    "Ring.toAddGroupWithOne",
    "Finset.sum_congr",
    "Finset.sum",
    "Neg.neg",
    "sub_neg_eq_add",
    "Eq.trans",
    "mul_neg",
    "Real.instCommSemiring",
    "instHMul",
    "AddRightCancelSemigroup.toIsRightCancelAdd"],
   "tactic":
   "norm_num [mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _]",
   "proofState": 99,
   "pos": {"line": 270, "column": 4},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\n⊢ -∑ x,\n        (rexp (-(T⁻¹ * levels.ε x)) * (partitionFunction levels T⁻¹)⁻¹ * log (rexp (-(T⁻¹ * levels.ε x))) -\n          rexp (-(T⁻¹ * levels.ε x)) * (partitionFunction levels T⁻¹)⁻¹ * log (partitionFunction levels T⁻¹)) =\n    log (partitionFunction levels T⁻¹) +\n      ∑ x, T⁻¹ * (partitionFunction levels T⁻¹)⁻¹ * levels.ε x * rexp (-(T⁻¹ * levels.ε x))",
   "endPos": {"line": 270, "column": 73}},
  {"usedConstants":
   ["Eq.mpr",
    "Finset.mul_sum",
    "NegZeroClass.toNeg",
    "Real",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "CommRing.toNonUnitalCommRing",
    "DivisionCommMonoid.toDivisionMonoid",
    "Finset.univ",
    "DivInvOneMonoid.toInvOneClass",
    "Ring.toNonAssocRing",
    "congrArg",
    "Finset",
    "Membership.mem",
    "DivisionMonoid.toDivInvOneMonoid",
    "Real.instCommSemigroup",
    "id",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
    "CommMagma.toMul",
    "SubtractionMonoid.toSubNegZeroMonoid",
    "Finset.instMembership",
    "Real.exp",
    "Real.commRing",
    "SubNegZeroMonoid.toNegZeroClass",
    "Real.instAddCommGroup",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "SubtractionCommMonoid.toSubtractionMonoid",
    "Real.log",
    "Field.toSemifield",
    "NonAssocRing.toNonUnitalNonAssocRing",
    "Fin.fintype",
    "SubtractionCommMonoid.toAddCommMonoid",
    "NonUnitalCommSemiring.toNonUnitalSemiring",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "NonUnitalNonAssocSemiring.toAddCommMonoid",
    "Inv.inv",
    "Real.normedCommRing",
    "Distrib.toMul",
    "NonUnitalCommRing.toNonUnitalCommSemiring",
    "Ring.toAddCommGroup",
    "Real.instMul",
    "congr",
    "Semifield.toCommGroupWithZero",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "CommSemigroup.toCommMagma",
    "Real.instNeg",
    "Real.instAddCommMonoid",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Eq.refl",
    "CommGroupWithZero.toDivisionCommMonoid",
    "neg_mul",
    "InvOneClass.toInv",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "HasDistribNeg.toInvolutiveNeg",
    "CommRing.toRing",
    "AddCommGroup.toDivisionAddCommMonoid",
    "InvolutiveNeg.toNeg",
    "NonUnitalNonAssocSemiring",
    "Eq.symm",
    "Fin",
    "Real.instField",
    "Eq",
    "EnergyLevels.ε",
    "partitionFunction",
    "Finset.sum_congr",
    "Finset.sum",
    "Neg.neg",
    "Eq.trans",
    "instHMul"],
   "tactic": "simp +decide [← Finset.mul_sum _ _ _, partitionFunction]",
   "proofState": 100,
   "pos": {"line": 271, "column": 4},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\n⊢ ∑ x, (partitionFunction levels T⁻¹)⁻¹ * (log (partitionFunction levels T⁻¹) * rexp (-(T⁻¹ * levels.ε x))) =\n    log (partitionFunction levels T⁻¹)",
   "endPos": {"line": 271, "column": 60}},
  {"usedConstants":
   ["Finset.mem_univ",
    "Eq.mpr",
    "GroupWithZero.toMonoidWithZero",
    "NegZeroClass.toNeg",
    "Nat.instCanonicallyOrderedAdd",
    "Real.partialOrder",
    "Real",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "GroupWithZero.toDivInvMonoid",
    "CommRing.toNonUnitalCommRing",
    "DivisionCommMonoid.toDivisionMonoid",
    "Finset.univ",
    "DivInvOneMonoid.toInvOneClass",
    "Ring.toNonAssocRing",
    "MulZeroClass.toMul",
    "Monoid.toMulOneClass",
    "congrArg",
    "Finset",
    "AddMonoid.toAddZeroClass",
    "DivisionSemiring.toGroupWithZero",
    "Nat.instAddMonoid",
    "Membership.mem",
    "DivisionMonoid.toDivInvOneMonoid",
    "Finset.sum_pos",
    "inv_mul_eq_div",
    "ne_of_gt",
    "Fin.mk",
    "id",
    "MulOne.toMul",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "DivInvMonoid.toMonoid",
    "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
    "SubtractionMonoid.toSubNegZeroMonoid",
    "instOfNatNat",
    "Finset.instMembership",
    "Real.exp",
    "Real.commRing",
    "SubNegZeroMonoid.toNegZeroClass",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "SubtractionCommMonoid.toSubtractionMonoid",
    "DivisionMonoid.toDivInvMonoid",
    "Real.log",
    "Field.toSemifield",
    "NonAssocRing.toNonUnitalNonAssocRing",
    "Fin.fintype",
    "NonUnitalCommSemiring.toNonUnitalSemiring",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "NonUnitalNonAssocSemiring.toAddCommMonoid",
    "MulOneClass.toMulOne",
    "div_eq_iff",
    "Inv.inv",
    "Semifield.toDivisionSemiring",
    "MonoidWithZero.toMulZeroOneClass",
    "Real.normedCommRing",
    "Distrib.toMul",
    "NonUnitalCommRing.toNonUnitalCommSemiring",
    "Ring.toAddCommGroup",
    "Nat",
    "Semifield.toCommGroupWithZero",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "propext",
    "Exists.intro",
    "DivInvMonoid.toDiv",
    "Nat.instPartialOrder",
    "Real.instAddCommMonoid",
    "NonUnitalNonAssocSemiring.toDistrib",
    "NeZero.pos",
    "Zero.toOfNat0",
    "Eq.refl",
    "CommGroupWithZero.toDivisionCommMonoid",
    "InvOneClass.toInv",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "MulZeroOneClass.toMulZeroClass",
    "HasDistribNeg.toInvolutiveNeg",
    "CommRing.toRing",
    "AddCommGroup.toDivisionAddCommMonoid",
    "InvolutiveNeg.toNeg",
    "OfNat.ofNat",
    "Fin",
    "Real.instField",
    "Eq",
    "EnergyLevels.ε",
    "Finset.sum",
    "Neg.neg",
    "Real.instPreorder",
    "MulZeroClass.toZero",
    "Real.exp_pos",
    "instHMul",
    "Real.instIsOrderedCancelAddMonoid"],
   "tactic":
   "rw [inv_mul_eq_div,\n  div_eq_iff (ne_of_gt <| Finset.sum_pos (fun _ _ => Real.exp_pos _) ⟨⟨0, NeZero.pos w⟩, Finset.mem_univ _⟩)]",
   "proofState": 101,
   "pos": {"line": 272, "column": 4},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\n⊢ (∑ x, rexp (-(T⁻¹ * levels.ε x)))⁻¹ * (log (∑ x, rexp (-(T⁻¹ * levels.ε x))) * ∑ i, rexp (-(T⁻¹ * levels.ε i))) =\n    log (∑ x, rexp (-(T⁻¹ * levels.ε x)))",
   "endPos": {"line": 272, "column": 141}},
  {"usedConstants":
   ["Eq.mpr",
    "MulOne.toOne",
    "Real.instLE",
    "Real",
    "DivInvMonoid.toInv",
    "instHDiv",
    "HMul.hMul",
    "ProbDist",
    "Real.instZero",
    "Monoid.toMulOneClass",
    "congrArg",
    "Real.instDivInvMonoid",
    "internalEnergy",
    "Eq.mp",
    "id",
    "HDiv.hDiv",
    "DivInvMonoid.toMonoid",
    "one_div_nonneg_of_pos",
    "LE.le",
    "Real.log",
    "Real.instAdd",
    "Real.instOne",
    "instHAdd",
    "MulOneClass.toMulOne",
    "Inv.inv",
    "HAdd.hAdd",
    "Real.instMul",
    "congr",
    "one_div",
    "boltzmannDist.congr_simp",
    "DivInvMonoid.toDiv",
    "gibbsEntropy",
    "Eq.ndrec",
    "One.toOfNat1",
    "Zero.toOfNat0",
    "Eq.refl",
    "freeEnergy",
    "boltzmannDist",
    "OfNat.ofNat",
    "Eq",
    "partitionFunction",
    "EnergyLevels",
    "Eq.trans",
    "instHMul"],
   "tactic": "simp_all +decide",
   "proofState": 102,
   "pos": {"line": 273, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\nh_gibbs_entropy :\n  gibbsEntropy (boltzmannDist levels (1 / T) ⋯) =\n    1 / T * internalEnergy levels (boltzmannDist levels (1 / T) ⋯) + log (partitionFunction levels (1 / T))\n⊢ let β := 1 / T;\n  let dist := boltzmannDist levels β ⋯;\n  let U := internalEnergy levels dist;\n  let S := gibbsEntropy dist;\n  let F := freeEnergy levels T;\n  U = F + T * S",
   "endPos": {"line": 273, "column": 18}},
  {"usedConstants":
   ["Real.instLE",
    "Real",
    "DivInvMonoid.toInv",
    "instHDiv",
    "HMul.hMul",
    "Real.instZero",
    "Real.instDivInvMonoid",
    "internalEnergy",
    "id",
    "HDiv.hDiv",
    "one_div_nonneg_of_pos",
    "LE.le",
    "Real.log",
    "Real.instAdd",
    "Real.instOne",
    "instHAdd",
    "Inv.inv",
    "HAdd.hAdd",
    "Real.instMul",
    "one_div",
    "DivInvMonoid.toDiv",
    "Eq.ndrec",
    "One.toOfNat1",
    "Zero.toOfNat0",
    "freeEnergy",
    "boltzmannDist",
    "OfNat.ofNat",
    "Eq",
    "partitionFunction",
    "instHMul"],
   "tactic": "unfold freeEnergy",
   "proofState": 103,
   "pos": {"line": 274, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\nh_gibbs_entropy :\n  gibbsEntropy (boltzmannDist levels T⁻¹ ⋯) =\n    T⁻¹ * internalEnergy levels (boltzmannDist levels T⁻¹ ⋯) + log (partitionFunction levels T⁻¹)\n⊢ internalEnergy levels (boltzmannDist levels T⁻¹ ⋯) =\n    freeEnergy levels T +\n      T * (T⁻¹ * internalEnergy levels (boltzmannDist levels T⁻¹ ⋯) + log (partitionFunction levels T⁻¹))",
   "endPos": {"line": 274, "column": 19}},
  {"usedConstants":
   ["Eq.mpr",
    "NonAssocSemiring.toAddCommMonoidWithOne",
    "Real.instLE",
    "Real",
    "DivInvMonoid.toInv",
    "instHDiv",
    "Mathlib.Meta.NormNum.IsNat.to_isNNRat",
    "GroupWithZero.toDivisionMonoid",
    "HMul.hMul",
    "GroupWithZero.toDivInvMonoid",
    "DivisionCommMonoid.toDivisionMonoid",
    "Nat.rawCast",
    "DivInvOneMonoid.toInvOneClass",
    "Ring.toNonAssocRing",
    "Mathlib.Tactic.Ring.mul_zero",
    "Mathlib.Tactic.Ring.mul_pf_left",
    "Real.instZero",
    "Real.instAddMonoid",
    "Real.instRCLike",
    "Mathlib.Tactic.Ring.add_pf_add_gt",
    "congrArg",
    "CommSemiring.toSemiring",
    "Mathlib.Tactic.Ring.add_overlap_pf_zero",
    "Mathlib.Tactic.Ring.inv_congr",
    "Mathlib.Tactic.Ring.neg_congr",
    "Real.instDivInvMonoid",
    "Mathlib.Tactic.Ring.neg_zero",
    "Mathlib.Tactic.Ring.mul_pf_right",
    "AddMonoid.toAddZeroClass",
    "Int.rawCast",
    "Mathlib.Tactic.Ring.one_mul",
    "AddGroupWithOne.toAddMonoidWithOne",
    "Mathlib.Tactic.Ring.zero_mul",
    "Mathlib.Meta.NormNum.IsNat.of_raw",
    "DivisionSemiring.toGroupWithZero",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "internalEnergy",
    "Mathlib.Tactic.Ring.instCommSemiringNat",
    "DivisionMonoid.toDivInvOneMonoid",
    "Monoid.toNatPow",
    "Real.semiring",
    "Mathlib.Tactic.Ring.neg_mul",
    "Mathlib.Tactic.Ring.neg_add",
    "id",
    "Distrib.toAdd",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "Int.ofNat",
    "Real.instRing",
    "NonAssocSemiring.toMulZeroOneClass",
    "instOfNatNat",
    "one_div_nonneg_of_pos",
    "Int",
    "AddCommMonoidWithOne.toAddMonoidWithOne",
    "Mathlib.Meta.NormNum.isNat_ofNat",
    "Mathlib.Meta.NormNum.isInt_mul",
    "Mathlib.Tactic.Ring.atom_pf'",
    "Mathlib.Meta.NormNum.isNNRat_inv_pos",
    "LE.le",
    "Mathlib.Tactic.Ring.inv_mul",
    "Real.commRing",
    "Mathlib.Tactic.Ring.add_pf_zero_add",
    "Real.log",
    "Field.toSemifield",
    "NonAssocRing.toNonUnitalNonAssocRing",
    "Mathlib.Tactic.Ring.mul_congr",
    "MulZeroOneClass.toMulOneClass",
    "Real.instAdd",
    "Real.instOne",
    "AddMonoidWithOne.toOne",
    "Mathlib.Tactic.Ring.add_mul",
    "Mathlib.Tactic.Ring.inv_single",
    "instHAdd",
    "Mathlib.Meta.NormNum.instAddMonoidWithOne'",
    "Mathlib.Tactic.Ring.add_pf_add_zero",
    "Inv.inv",
    "Semifield.toDivisionSemiring",
    "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
    "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
    "HPow.hPow",
    "Distrib.toMul",
    "HAdd.hAdd",
    "Mathlib.Meta.NormNum.IsInt.to_isNat",
    "pow_one",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Nat",
    "Real.instMul",
    "Mathlib.Tactic.Ring.div_congr",
    "Mathlib.Tactic.Ring.mul_one",
    "congr",
    "Semifield.toCommGroupWithZero",
    "one_div",
    "Nat.instCommSemiring",
    "Real.instNeg",
    "DivInvMonoid.toDiv",
    "Mathlib.Meta.NormNum.IsNNRat.to_isNat",
    "DivisionSemiring.toSemiring",
    "Mathlib.Tactic.Ring.add_pf_add_lt",
    "Eq.ndrec",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Zero.toOfNat0",
    "Mathlib.Meta.NormNum.isInt_add",
    "Eq.refl",
    "CommGroupWithZero.toDivisionCommMonoid",
    "Mathlib.Meta.NormNum.IsInt.of_raw",
    "InvOneClass.toInv",
    "instHPow",
    "Mathlib.Tactic.Ring.cast_pos",
    "Mathlib.Tactic.RingNF.nat_rawCast_1",
    "Mathlib.Tactic.RingNF.mul_assoc_rev",
    "CommRing.toRing",
    "mul_one",
    "boltzmannDist",
    "Mathlib.Tactic.Ring.atom_pf",
    "add_zero",
    "Mathlib.Tactic.Ring.div_pf",
    "OfNat.ofNat",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "Nat.cast_one",
    "partitionFunction",
    "RCLike.charZero_rclike",
    "Mathlib.Tactic.Ring.neg_one_mul",
    "Ring.toAddGroupWithOne",
    "Neg.neg",
    "MonoidWithZero.toMonoid",
    "Mathlib.Tactic.Ring.mul_add",
    "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
    "Eq.trans",
    "Int.negOfNat",
    "MulZeroClass.toZero",
    "Mathlib.Tactic.Ring.add_congr",
    "Real.instCommSemiring",
    "Mathlib.Meta.NormNum.IsNat.to_isInt",
    "Semiring.toMonoidWithZero",
    "instHMul"],
   "tactic": "ring_nf",
   "proofState": 104,
   "pos": {"line": 274, "column": 21},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\nh_gibbs_entropy :\n  gibbsEntropy (boltzmannDist levels T⁻¹ ⋯) =\n    T⁻¹ * internalEnergy levels (boltzmannDist levels T⁻¹ ⋯) + log (partitionFunction levels T⁻¹)\n⊢ internalEnergy levels (boltzmannDist levels T⁻¹ ⋯) =\n    -T * log (partitionFunction levels (1 / T)) +\n      T * (T⁻¹ * internalEnergy levels (boltzmannDist levels T⁻¹ ⋯) + log (partitionFunction levels T⁻¹))",
   "endPos": {"line": 274, "column": 28}},
  {"usedConstants":
   ["GroupWithZero.toMonoidWithZero",
    "MulOne.toOne",
    "False",
    "Real.instLE",
    "Real",
    "DivInvMonoid.toInv",
    "instHDiv",
    "HMul.hMul",
    "GroupWithZero.toDivInvMonoid",
    "DivisionCommMonoid.toDivisionMonoid",
    "DivInvOneMonoid.toInvOneClass",
    "eq_false",
    "mul_inv_cancel₀",
    "MulZeroClass.toMul",
    "Real.instZero",
    "congrArg",
    "CommSemiring.toSemiring",
    "Real.instDivInvMonoid",
    "DivisionSemiring.toGroupWithZero",
    "internalEnergy",
    "DivisionMonoid.toDivInvOneMonoid",
    "Real.semiring",
    "HDiv.hDiv",
    "NonAssocSemiring.toMulZeroOneClass",
    "one_div_nonneg_of_pos",
    "LE.le",
    "Field.toSemifield",
    "MulZeroOneClass.toMulOneClass",
    "Real.instOne",
    "LT.lt.ne'",
    "MulOneClass.toMulOne",
    "not_false",
    "Inv.inv",
    "Semifield.toDivisionSemiring",
    "MonoidWithZero.toMulZeroOneClass",
    "Distrib.toMul",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Semifield.toCommGroupWithZero",
    "one_div",
    "True",
    "eq_self",
    "DivInvMonoid.toDiv",
    "eq_true",
    "of_eq_true",
    "Eq.ndrec",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Zero.toOfNat0",
    "CommGroupWithZero.toDivisionCommMonoid",
    "InvOneClass.toInv",
    "MulZeroOneClass.toMulZeroClass",
    "boltzmannDist",
    "OfNat.ofNat",
    "not_false_eq_true",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "Not",
    "Real.instPreorder",
    "one_mul",
    "Eq.trans",
    "Real.instCommSemiring",
    "True.intro",
    "instHMul"],
   "tactic": "norm_num [hT.ne']",
   "proofState": 105,
   "pos": {"line": 274, "column": 30},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\nh_gibbs_entropy :\n  gibbsEntropy (boltzmannDist levels T⁻¹ ⋯) =\n    T⁻¹ * internalEnergy levels (boltzmannDist levels T⁻¹ ⋯) + log (partitionFunction levels T⁻¹)\n⊢ internalEnergy levels (boltzmannDist levels T⁻¹ ⋯) = T * T⁻¹ * internalEnergy levels (boltzmannDist levels T⁻¹ ⋯)",
   "endPos": {"line": 274, "column": 49}},
  {"usedConstants":
   ["Mathlib.Tactic.FieldSimp.zpow'_one",
    "Eq.mpr",
    "GroupWithZero.toMonoidWithZero",
    "Mathlib.Tactic.FieldSimp.eq_div_of_eq_one_of_subst",
    "Real.partialOrder",
    "Real",
    "instHDiv",
    "NeZero.one",
    "Mathlib.Tactic.FieldSimp.NF.cons_ne_zero",
    "GroupWithZero.toDivisionMonoid",
    "InvOneClass.toOne",
    "HMul.hMul",
    "GroupWithZero.toDivInvMonoid",
    "DivisionCommMonoid.toDivisionMonoid",
    "DivInvOneMonoid.toInvOneClass",
    "MulZeroClass.toMul",
    "ProbDist",
    "Real.instZero",
    "congrArg",
    "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval",
    "Real.instDivInvMonoid",
    "Mathlib.Tactic.FieldSimp.NF.one_div_eq_eval",
    "PartialOrder.toPreorder",
    "GroupWithZero",
    "CommGroupWithZero.toCancelCommMonoidWithZero",
    "internalEnergy",
    "DivisionMonoid.toDivInvOneMonoid",
    "inferInstance",
    "ne_of_gt",
    "id",
    "HDiv.hDiv",
    "Int.instNegInt",
    "Prod.mk",
    "one_div_nonneg_of_pos",
    "Int",
    "Real.log",
    "Field.toSemifield",
    "Mathlib.Tactic.FieldSimp.NF.mul_eq_eval",
    "Prod.fst",
    "MulZeroOneClass.toMulOneClass",
    "Real.instAdd",
    "Mathlib.Tactic.FieldSimp.NF.eval",
    "Real.instOne",
    "Mathlib.Tactic.FieldSimp.eq_eq_cancel_eq",
    "Mathlib.Tactic.FieldSimp.NF.eval_mul_eval_cons",
    "instHAdd",
    "Mathlib.Tactic.FieldSimp.NF.cons",
    "Mathlib.Tactic.FieldSimp.NF.div_eq_eval",
    "Semifield.toDivisionSemiring",
    "MonoidWithZero.toMulZeroOneClass",
    "instOfNat",
    "HAdd.hAdd",
    "Mathlib.Tactic.FieldSimp.NF.atom_eq_eval",
    "Mathlib.Tactic.FieldSimp.zpow'",
    "Real.instMul",
    "Mathlib.Tactic.FieldSimp.NF.one_eq_eval",
    "Semifield.toCommGroupWithZero",
    "CancelCommMonoidWithZero.toCancelMonoidWithZero",
    "CommGroupWithZero",
    "Mathlib.Tactic.FieldSimp.subst_add",
    "Mathlib.Tactic.FieldSimp.NF.cons_eq_div_of_eq_div",
    "DivInvMonoid.toDiv",
    "DivisionSemiring.toSemiring",
    "gibbsEntropy",
    "One.toOfNat1",
    "Zero.toOfNat0",
    "Eq.refl",
    "CommGroupWithZero.toDivisionCommMonoid",
    "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval_cons_neg",
    "Mathlib.Tactic.FieldSimp.eq_mul_of_eq_eq_eq_mul",
    "MulZeroOneClass.toMulZeroClass",
    "mul_one",
    "boltzmannDist",
    "CommGroupWithZero.toGroupWithZero",
    "Prod",
    "one_ne_zero",
    "OfNat.ofNat",
    "Eq.symm",
    "GroupWithZero.toNontrivial",
    "Real.instField",
    "Eq",
    "Prod.snd",
    "div_one",
    "partitionFunction",
    "Mathlib.Tactic.FieldSimp.NF.eval_cons",
    "Mathlib.Tactic.FieldSimp.NF.mul_eq_eval₃",
    "Neg.neg",
    "one_mul",
    "rfl",
    "Eq.trans",
    "MulZeroClass.toZero",
    "instHMul",
    "List.nil",
    "congr_arg₂"],
   "tactic": "field_simp",
   "proofState": 106,
   "pos": {"line": 282, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\n⊢ let β := 1 / T;\n  let dist := boltzmannDist levels β ⋯;\n  gibbsEntropy dist = log (partitionFunction levels β) + β * internalEnergy levels dist",
   "endPos": {"line": 282, "column": 12}},
  {"usedConstants":
   ["Real",
    "instHDiv",
    "HMul.hMul",
    "ProbDist",
    "Real.instDivInvMonoid",
    "internalEnergy",
    "HDiv.hDiv",
    "one_div_nonneg_of_pos",
    "Real.instAdd",
    "Real.instOne",
    "instHAdd",
    "HAdd.hAdd",
    "Real.instMul",
    "DivInvMonoid.toDiv",
    "gibbsEntropy",
    "One.toOfNat1",
    "freeEnergy",
    "boltzmannDist",
    "OfNat.ofNat",
    "beta_equals_inverse_temperature",
    "Eq",
    "instHMul"],
   "tactic": "have := beta_equals_inverse_temperature levels T hT",
   "proofState": 107,
   "pos": {"line": 283, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\n⊢ T * gibbsEntropy (boltzmannDist levels (1 / T) ⋯) =\n    T * log (partitionFunction levels (1 / T)) + internalEnergy levels (boltzmannDist levels (1 / T) ⋯)",
   "endPos": {"line": 283, "column": 53}},
  {"usedConstants": [],
   "tactic": "unfold freeEnergy at *",
   "proofState": 108,
   "pos": {"line": 284, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\nthis :\n  let β := 1 / T;\n  have dist := boltzmannDist levels β ⋯;\n  have U := internalEnergy levels dist;\n  have S := gibbsEntropy dist;\n  have F := freeEnergy levels T;\n  U = F + T * S\n⊢ T * gibbsEntropy (boltzmannDist levels (1 / T) ⋯) =\n    T * log (partitionFunction levels (1 / T)) + internalEnergy levels (boltzmannDist levels (1 / T) ⋯)",
   "endPos": {"line": 284, "column": 24}},
  {"usedConstants":
   ["GroupWithZero.toMonoidWithZero",
    "MulOne.toOne",
    "Real.instLE",
    "Real",
    "DivInvMonoid.toInv",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "InvOneClass.toOne",
    "HMul.hMul",
    "add_neg_cancel_left",
    "GroupWithZero.toDivInvMonoid",
    "DivisionCommMonoid.toDivisionMonoid",
    "DivInvOneMonoid.toInvOneClass",
    "MulZeroClass.toMul",
    "ProbDist",
    "Real.instZero",
    "Monoid.toMulOneClass",
    "congrArg",
    "Real.instDivInvMonoid",
    "internalEnergy",
    "DivisionMonoid.toDivInvOneMonoid",
    "inferInstance",
    "Eq.mp",
    "id",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "DivInvMonoid.toMonoid",
    "Real.instAddGroup",
    "one_div_nonneg_of_pos",
    "LE.le",
    "NormedCommRing.toNonUnitalNormedCommRing",
    "Real.log",
    "Field.toSemifield",
    "Real.instAdd",
    "NonUnitalNonAssocRing.toHasDistribNeg",
    "Real.instOne",
    "instHAdd",
    "MulOneClass.toMulOne",
    "Inv.inv",
    "MonoidWithZero.toMulZeroOneClass",
    "Real.normedCommRing",
    "Distrib.toMul",
    "HAdd.hAdd",
    "Real.instMul",
    "congr",
    "Semifield.toCommGroupWithZero",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "one_div",
    "True",
    "CommGroupWithZero",
    "Real.instNeg",
    "eq_self",
    "boltzmannDist.congr_simp",
    "DivInvMonoid.toDiv",
    "gibbsEntropy",
    "of_eq_true",
    "Eq.ndrec",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "Zero.toOfNat0",
    "Eq.refl",
    "CommGroupWithZero.toDivisionCommMonoid",
    "neg_mul",
    "NonUnitalNormedCommRing.toNonUnitalCommRing",
    "MulZeroOneClass.toMulZeroClass",
    "HasDistribNeg.toInvolutiveNeg",
    "boltzmannDist",
    "CommGroupWithZero.toGroupWithZero",
    "InvolutiveNeg.toNeg",
    "OfNat.ofNat",
    "Real.instField",
    "Eq",
    "partitionFunction",
    "EnergyLevels",
    "Neg.neg",
    "Eq.trans",
    "instHMul"],
   "tactic": "aesop",
   "proofState": 109,
   "pos": {"line": 284, "column": 26},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\nthis :\n  let β := 1 / T;\n  have dist := boltzmannDist levels β ⋯;\n  have U := internalEnergy levels dist;\n  have S := gibbsEntropy dist;\n  have F := -T * log (partitionFunction levels (1 / T));\n  U = F + T * S\n⊢ T * gibbsEntropy (boltzmannDist levels (1 / T) ⋯) =\n    T * log (partitionFunction levels (1 / T)) + internalEnergy levels (boltzmannDist levels (1 / T) ⋯)",
   "endPos": {"line": 284, "column": 31}},
  {"usedConstants":
   ["Real",
    "instHDiv",
    "HMul.hMul",
    "ProbDist",
    "Real.instDivInvMonoid",
    "internalEnergy",
    "HDiv.hDiv",
    "one_div_nonneg_of_pos",
    "Real.instAdd",
    "Real.instOne",
    "instHAdd",
    "HAdd.hAdd",
    "Real.instMul",
    "DivInvMonoid.toDiv",
    "gibbsEntropy",
    "One.toOfNat1",
    "freeEnergy",
    "boltzmannDist",
    "OfNat.ofNat",
    "beta_equals_inverse_temperature",
    "Eq",
    "instHMul"],
   "tactic": "have := @beta_equals_inverse_temperature w _ levels T hT",
   "proofState": 110,
   "pos": {"line": 291, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\n⊢ let β := 1 / T;\n  let dist := boltzmannDist levels β ⋯;\n  freeEnergy levels T = internalEnergy levels dist - T * gibbsEntropy dist",
   "endPos": {"line": 291, "column": 58}},
  {"usedConstants":
   ["Iff.mpr",
    "AddGroup.toSubtractionMonoid",
    "Real.instIsOrderedRing",
    "Not.intro",
    "NegZeroClass.toNeg",
    "NonAssocSemiring.toAddCommMonoidWithOne",
    "Real.partialOrder",
    "Real",
    "Mathlib.Meta.NormNum.instAddMonoidWithOne",
    "Preorder.toLT",
    "instHDiv",
    "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
    "HMul.hMul",
    "CommRing.toNonUnitalCommRing",
    "Mathlib.Meta.NormNum.isNat_eq_true",
    "Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt",
    "Nat.rawCast",
    "AddMonoid.toAddSemigroup",
    "Ring.toNonAssocRing",
    "Mathlib.Tactic.Ring.mul_zero",
    "ProbDist",
    "Mathlib.Tactic.Ring.mul_pf_left",
    "Real.instZero",
    "Real.instAddMonoid",
    "AddGroupWithOne.toAddGroup",
    "Mathlib.Tactic.Ring.add_pf_add_gt",
    "congrArg",
    "CommSemiring.toSemiring",
    "Mathlib.Tactic.Ring.add_overlap_pf_zero",
    "Mathlib.Tactic.Ring.neg_congr",
    "Real.instDivInvMonoid",
    "Mathlib.Tactic.Ring.neg_zero",
    "Real.instSub",
    "Mathlib.Tactic.Ring.mul_pf_right",
    "Int.rawCast",
    "PartialOrder.toPreorder",
    "Mathlib.Tactic.Ring.one_mul",
    "AddGroupWithOne.toAddMonoidWithOne",
    "HSub.hSub",
    "Mathlib.Tactic.Ring.zero_mul",
    "Mathlib.Meta.NormNum.IsNat.of_raw",
    "NonUnitalNonAssocSemiring.toMulZeroClass",
    "Mul",
    "internalEnergy",
    "Mathlib.Tactic.Ring.instCommSemiringNat",
    "Field.toDivisionRing",
    "SemilatticeInf.toPartialOrder",
    "Monoid.toNatPow",
    "Mathlib.Tactic.Ring.cast_zero",
    "Mathlib.Tactic.Linarith.without_one_mul",
    "inferInstance",
    "Real.semiring",
    "Mathlib.Tactic.Ring.neg_mul",
    "Eq.mp",
    "DistribLattice.toLattice",
    "neg_eq_zero",
    "Mathlib.Tactic.Ring.sub_pf",
    "sub_eq_zero_of_eq",
    "Mathlib.Tactic.Ring.neg_add",
    "Distrib.toAdd",
    "HDiv.hDiv",
    "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
    "Int.ofNat",
    "Real.instAddGroup",
    "DivisionRing.toRing",
    "Real.instRing",
    "SubtractionMonoid.toSubNegZeroMonoid",
    "NonAssocSemiring.toMulZeroOneClass",
    "one_div_nonneg_of_pos",
    "Int",
    "AddCommMonoidWithOne.toAddMonoidWithOne",
    "Mathlib.Tactic.Ring.sub_congr",
    "Mathlib.Meta.NormNum.isNat_ofNat",
    "Mathlib.Meta.NormNum.isInt_mul",
    "Real.commRing",
    "SubNegZeroMonoid.toNegZeroClass",
    "Mathlib.Tactic.Ring.of_eq",
    "Real.instAddCommGroup",
    "Mathlib.Tactic.Ring.add_pf_zero_add",
    "SubtractionCommMonoid.toSubtractionMonoid",
    "NonAssocRing.toNonUnitalNonAssocRing",
    "Field.toCommRing",
    "Mathlib.Tactic.Ring.mul_congr",
    "MulZeroOneClass.toMulOneClass",
    "Real.instAdd",
    "Real.instOne",
    "SubNegMonoid.toSub",
    "AddMonoidWithOne.toOne",
    "Mathlib.Tactic.Ring.add_mul",
    "instHAdd",
    "AddSemigroup.toAdd",
    "Mathlib.Tactic.Linarith.sub_neg_of_lt",
    "Mathlib.Tactic.Ring.add_pf_add_zero",
    "instHSub",
    "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
    "AddGroup.toSubNegMonoid",
    "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
    "HPow.hPow",
    "Distrib.toMul",
    "HAdd.hAdd",
    "Mathlib.Meta.NormNum.IsInt.to_isNat",
    "CancelDenoms.mul_subst",
    "NonAssocSemiring.toNonUnitalNonAssocSemiring",
    "Nat",
    "Real.instMul",
    "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
    "LT.lt",
    "DivInvMonoid.toDiv",
    "gibbsEntropy",
    "Mathlib.Tactic.Ring.add_pf_add_lt",
    "Mathlib.Meta.NormNum.isNat_mul",
    "One.toOfNat1",
    "NonUnitalNonAssocSemiring.toDistrib",
    "CancelDenoms.sub_subst",
    "Zero.toOfNat0",
    "Mathlib.Meta.NormNum.isInt_add",
    "Eq.refl",
    "Mathlib.Meta.NormNum.IsInt.of_raw",
    "instHPow",
    "Nat.cast_zero",
    "Mathlib.Tactic.Ring.cast_pos",
    "CancelDenoms.add_subst",
    "freeEnergy",
    "CommRing.toRing",
    "boltzmannDist",
    "Mathlib.Tactic.Ring.atom_pf",
    "AddCommGroup.toDivisionAddCommMonoid",
    "OfNat.ofNat",
    "NegZeroClass.toZero",
    "Real.instField",
    "Semiring.toNonAssocSemiring",
    "Eq",
    "Mathlib.Tactic.Linarith.lt_of_eq_of_lt",
    "Nat.cast_one",
    "Mathlib.Tactic.Ring.neg_one_mul",
    "Ring.toAddGroupWithOne",
    "Mathlib.Tactic.Linarith.lt_irrefl",
    "instDistribLatticeOfLinearOrder",
    "Neg.neg",
    "Real.instPreorder",
    "MonoidWithZero.toMonoid",
    "rfl",
    "Mathlib.Tactic.Ring.mul_add",
    "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
    "Real.linearOrder",
    "Int.negOfNat",
    "MulZeroClass.toZero",
    "AddMonoidWithOne",
    "Lattice.toSemilatticeInf",
    "Mathlib.Tactic.Ring.add_congr",
    "Real.instCommSemiring",
    "Mathlib.Meta.NormNum.IsNat.to_isInt",
    "Semiring.toMonoidWithZero",
    "instHMul"],
   "tactic": "bound",
   "proofState": 111,
   "pos": {"line": 292, "column": 2},
   "goals":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w\nT : ℝ\nhT : 0 < T\nthis :\n  let β := 1 / T;\n  have dist := boltzmannDist levels β ⋯;\n  have U := internalEnergy levels dist;\n  have S := gibbsEntropy dist;\n  have F := freeEnergy levels T;\n  U = F + T * S\n⊢ let β := 1 / T;\n  let dist := boltzmannDist levels β ⋯;\n  freeEnergy levels T = internalEnergy levels dist - T * gibbsEntropy dist",
   "endPos": {"line": 292, "column": 7}}],
 "sorries":
 [{"proofState": 0,
   "pos": {"line": 142, "column": 2},
   "goal":
   "w : ℕ\ninst✝ : NeZero w\nlevels : EnergyLevels w inst✝\np : Fin w → ℝ\nhp_pos : ∀ (i : Fin w), 0 < p i\nhp_normalized : ∑ i, p i = 1\nhp_functional : ∀ (a b : Fin w) (hab : ↑a + ↑b < w), p a * p b = p ⟨0, ⋯⟩ * p ⟨↑a + ↑b, hab⟩\n⊢ ∃ β, ∀ (i : Fin w), p i = boltzmannProb w inst✝ levels β i",
   "endPos": {"line": 142, "column": 7}},
  {"proofState": 1,
   "pos": {"line": 214, "column": 2},
   "goal": "⊢ ∀ {p : Prop}, ¬p → p",
   "endPos": {"line": 214, "column": 14}}],
 "messages":
 [{"severity": "warning",
   "pos": {"line": 110, "column": 5},
   "endPos": {"line": 110, "column": 7},
   "data":
   "unused variable `hβ`\n\nNote: This linter can be disabled with `set_option linter.unusedVariables false`"},
  {"severity": "warning",
   "pos": {"line": 115, "column": 5},
   "endPos": {"line": 115, "column": 7},
   "data":
   "unused variable `hβ`\n\nNote: This linter can be disabled with `set_option linter.unusedVariables false`"},
  {"severity": "warning",
   "pos": {"line": 135, "column": 8},
   "endPos": {"line": 135, "column": 48},
   "data": "declaration uses 'sorry'"},
  {"severity": "warning",
   "pos": {"line": 158, "column": 34},
   "endPos": {"line": 158, "column": 42},
   "data":
   "this tactic is never executed\n\nNote: This linter can be disabled with `set_option linter.unreachableTactic false`"},
  {"severity": "warning",
   "pos": {"line": 158, "column": 34},
   "endPos": {"line": 158, "column": 42},
   "data":
   "'norm_num' tactic does nothing\n\nNote: This linter can be disabled with `set_option linter.unusedTactic false`"},
  {"severity": "warning",
   "pos": {"line": 190, "column": 5},
   "endPos": {"line": 190, "column": 11},
   "data":
   "unused variable `hp_pos`\n\nNote: This linter can be disabled with `set_option linter.unusedVariables false`"},
  {"severity": "warning",
   "pos": {"line": 191, "column": 5},
   "endPos": {"line": 191, "column": 18},
   "data":
   "unused variable `hp_normalized`\n\nNote: This linter can be disabled with `set_option linter.unusedVariables false`"},
  {"severity": "warning",
   "pos": {"line": 192, "column": 5},
   "endPos": {"line": 192, "column": 18},
   "data":
   "unused variable `hp_functional`\n\nNote: This linter can be disabled with `set_option linter.unusedVariables false`"},
  {"severity": "warning",
   "pos": {"line": 206, "column": 8},
   "endPos": {"line": 206, "column": 41},
   "data": "declaration uses 'sorry'"},
  {"severity": "warning",
   "pos": {"line": 252, "column": 84},
   "endPos": {"line": 252, "column": 86},
   "data":
   "unused variable `hT`\n\nNote: This linter can be disabled with `set_option linter.unusedVariables false`"}],
 "env": 0}

